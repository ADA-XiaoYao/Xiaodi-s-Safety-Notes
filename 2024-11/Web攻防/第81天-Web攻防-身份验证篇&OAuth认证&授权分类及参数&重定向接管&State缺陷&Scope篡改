在当今的Web应用架构中，身份认证与授权是构筑信任的基石。JWT（JSON Web Token） 以其无状态、跨域的特性，成为分布式系统会话管理的宠儿；而 OAuth 2.0 则作为行业标准的授权协议，让“使用XX账号登录”变得无处不在。然而，权柄在手，其暗面亦不可忽视。本文将结合前沿的攻防对抗视角，深入剖析JWT与OAuth在落地实现中的常见漏洞、攻击手法及实战检测方法，帮助开发者与安全从业者构建更健壮的防护体系。

一、 JWT：无状态信任的双刃剑

JWT的本质是一串自包含的、经过签名的令牌，它由三部分构成：Header（标头）、Payload（载荷） 和 Signature（签名）。服务器不存储会话，完全依赖于对签名的验证来放行请求。

1. 核心攻击面解析

攻击者对JWT的利用，核心思路是绕过或操纵签名验证机制。

· 算法操纵与空加密攻击：Header中的 alg 字段声明了签名算法。当服务器未严格校验该字段时，攻击者可将其篡改为 none，并移除Signature部分，使任何令牌都被视为有效。
· 密钥爆破与弱密钥：若JWT使用对称加密算法（如HS256），且密钥强度不足，攻击者可借助 jwt_tool、hashcat 等工具配合常用密钥字典（如 jwt-secrets 项目）爆破出密钥，进而伪造任意身份的令牌。
· 算法混淆攻击 (RS256 → HS256)：这是一种经典的逻辑漏洞。当服务器预期使用非对称算法RS256（私钥签名，公钥验证），但攻击者将Header中的 alg 改为HS256（对称算法）后，服务器可能误用已知的公钥作为HS256的密钥来验证签名。攻击者只需用该公钥对令牌重新签名，即可绕过验证。
· Header参数注入 (JKU, JWK, KID)：Header中的 jku（JWK Set URL）、jwk（内嵌公钥）和 kid（密钥ID）用于指定验证密钥。若服务器未做严格校验，攻击者可以：
  1. JKU注入：修改 jku 指向自己控制的Web服务器，该服务器返回伪造的JWK公钥集。
  2. JWK注入：直接在Header中嵌入恶意的 jwk 公钥。
  3. KID注入：kid 常用于从文件系统或数据库查找密钥文件。通过注入路径遍历（如 ../../../../dev/null）或SQL注入载荷，可能导致服务器使用空密钥、任意文件内容作为密钥，或引发其他后端漏洞。

2. 实战检测与利用

在实际渗透测试中，面对一个使用JWT的应用，可以遵循以下流程：

1. 识别与解码：通过Burp Suite插件（如JSON Web Tokens）或在线工具（jwt.io）识别请求中的JWT，并解码Payload部分，分析其中是否泄露敏感信息（如弱加密密码、内部ID）。
2. 未授权访问探测：尝试删除Token或将其修改为空值，观察响应是否返回数据。
3. 时效性绕过：检查Payload中是否包含 exp（过期时间）字段。若无此字段，或修改过期时间后仍能通过验证，则存在令牌永不失效的风险。
4. 越权与伪造：
   · 空算法：将 alg 改为 none，移除签名部分，重放请求。
   · 密钥爆破：使用 jwt_tool 配合字典爆破HS256密钥。成功后修改Payload中的用户名（如 user: admin），重新签名生成新令牌。
   · 算法混淆：若能获取到RS256的公钥（如通过 jku 泄露、.well-known/jwks.json 端点），使用 PyJWT 或 jsonwebtoken 库，用公钥作为密钥，以HS256算法重新签名令牌。
5. 参数注入探测：修改 kid 为 ../../../etc/passwd 或SQL注入语句，观察服务器响应错误或变化。修改 jku 为自己服务器的地址，看服务器是否发起请求。

二、 OAuth 2.0：授权协议的信任陷阱

OAuth 2.0旨在解决“授权”问题，让第三方应用能有限度地访问用户资源。然而，其在实现中的逻辑复杂性，尤其是对回调地址、状态参数和权限范围的错误处理，滋生了大量高危漏洞。

1. 核心攻击面解析

· 无State参数的CSRF攻击：state 参数是OAuth流程中维持客户端状态、防止CSRF的关键。若缺失此参数或其值可预测，攻击者可构造恶意绑定链接，诱使受害者点击。当受害者在已登录目标站点的状态下访问此链接，攻击者的第三方账号便会与受害者的账户绑定，导致攻击者后续可直接登录受害者账号（如提供的案例“某厂商OAuth绑定漏洞”所示）。
· 回调地址劫持 (Open Redirect)：授权码 code 通常通过重定向到 redirect_uri 传递给客户端。若服务端未对 redirect_uri 进行严格的白名单校验，攻击者可将其修改为恶意站点。当用户完成授权后，包含授权码的请求会被转发到攻击者服务器，攻击者即可窃取 code 并接管账户。
· Scope权限范围篡改：scope 参数定义了第三方应用请求的权限。若服务端未对用户授权的 scope 与最终发放令牌的 scope 进行严格比对，攻击者可能在授权流程中通过修改 scope 参数来提升权限（例如，从读取基本信息升级为修改密码），实现越权操作。
· 授权码/令牌泄露：code 或 access_token 可能通过以下方式泄露：
  · Referer头泄露：页面中引用了第三方资源，导致Referer头中携带了包含敏感信息的URL。
  · 日志记录：服务器、客户端或代理服务器日志记录了完整的URL。
  · 不安全的传输：使用了HTTP协议传输回调请求。

2. 实战案例复盘：从绑定劫持到账户接管

以“某厂商OAuth绑定漏洞”为例，其攻击链清晰展示了OAuth CSRF的威力：

1. 攻击准备：攻击者拥有自己的微博账号A和目标厂商的账号B。
2. 捕获关键链接：攻击者登录账号B，点击“绑定微博”，在授权流程中抓取到最终的回调URL，其中包含了微博授权码。
3. 构造诱饵：攻击者将此URL发送给无辜的目标厂商用户C（例如，通过私信、钓鱼邮件）。
4. 触发绑定：用户C在已登录自己厂商账号的状态下点击该URL。由于OAuth流程中缺少state校验，该请求成功将攻击者的微博账号A与用户C的厂商账号绑定。
5. 成功接管：攻击者随后点击“使用微博登录”，即可直接进入用户C的厂商账户，实现完全接管。

另一个“Google OAuth回调劫持”案例则揭示了 redirect_uri 验证不严的危害。攻击者通过移除非关键参数，并尝试修改 callbackUrl 为其 webhook，最终成功捕获了包含访问令牌的重定向请求。

三、 防御加固：构建信任的最后一道防线

1. JWT 安全实践

· 严格验证算法：强制使用预定义的算法列表，拒绝 none 算法。在验证签名前，必须校验 alg 字段是否在预期白名单内。
· 使用强密钥：HS256必须使用高熵的复杂密钥。RS256需妥善保管私钥，并确保公钥来源可信（如通过HTTPS提供）。
· 防范参数注入：禁用或严格限制 jku、jwk、x5u 等外部资源引用。若必须使用 kid，应对其进行消毒，防止路径遍历或注入攻击。
· 设置短期有效：务必包含 exp（过期时间）和 nbf（生效时间）声明，并采用短生命周期的令牌，配合Refresh Token机制刷新。

2. OAuth 2.0 安全实践

· 强制使用state参数：生成并验证不可预测的随机 state 值，将其与用户会话绑定，这是防御CSRF绑定攻击的根本。
· 严格校验redirect_uri：采用精确的白名单列表进行完全匹配验证，拒绝任何未在列表中注册的域名或路径，防止开放重定向。
· 最小化权限原则：仔细评估请求的 scope，并向用户清晰展示。在颁发令牌前，确保令牌权限不超过用户授权的 scope。
· 安全传输与存储：全程使用HTTPS。授权码 code 应设计为一次性的、短期有效的，并在后端通过client_secret等凭证进行交换，避免前端直接暴露 access_token。

结语

JWT与OAuth作为现代Web认证授权的基石，其安全性高度依赖于实现的严谨性。无论是JWT中对签名算法的“狸猫换太子”，还是OAuth中对回调地址的“移花接木”，其根本原因往往是开发者对协议规范的理解存在盲区，或对用户输入的信任过度。

安全是一场无休止的攻防博弈。对于开发者而言，深入理解这些机制的内在逻辑与常见陷阱，遵循最佳安全实践，是构建可信应用的必修课。对于安全人员来说，掌握这些攻击链的每一个环节，才能在复杂的系统中精准地发现并修复那些隐藏在信任背后的权柄暗面。
