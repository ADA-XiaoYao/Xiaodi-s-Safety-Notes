引言

JSON Web Token（JWT）作为一种轻量级的身份认证与信息交换标准，因其无状态、跨语言、易于扩展的特点，在现代分布式Web应用、微服务架构及单页应用中得到了广泛采用。它允许服务器无需存储会话信息，仅通过验证令牌本身即可确认用户身份，极大地简化了认证流程。然而，JWT的安全性完全依赖于其实现和配置的正确性。如果开发人员对JWT的机制理解不深或配置不当，则可能引入严重的安全漏洞，导致身份伪造、权限提升、信息泄露等风险。

本文将从JWT的基础结构出发，深入剖析其潜在的安全风险，并结合实际攻击案例与工具，详细介绍各类绕过技术与利用手法，最后提出相应的防御策略，帮助安全从业者与开发人员构建更为健壮的JWT认证体系。

一、JWT基础回顾

1.1 JWT的结构

JWT本质上是一个经过签名或加密的JSON字符串，由三个部分通过点号.连接而成：

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

· Header（头部）：一个JSON对象，描述令牌的元数据，通常包含alg（签名算法）和typ（类型，一般为JWT）。还可包含kid（密钥ID）、jku（JWK Set URL）、jwk（内嵌公钥）等扩展字段。
· Payload（载荷）：存放实际声明的JSON对象，如用户ID、角色、过期时间（exp）、签发者（iss）等。Payload默认是明文Base64编码，不加密，因此不能存放敏感信息。
· Signature（签名）：由Header和Payload拼接后，使用指定算法和密钥计算出的签名值，用于防止数据被篡改。

1.2 常见签名算法

· HS256：HMAC-SHA256对称加密算法，使用同一个密钥进行签名和验证。
· RS256：RSA-SHA256非对称加密算法，使用私钥签名，公钥验证。
· ES256：基于ECDSA的椭圆曲线算法，也属于非对称加密。

算法选择直接影响后续攻击向量。对称密钥需要妥善保管，非对称密钥则需确保公钥可信。

1.3 JWT的识别

在Web应用中，JWT通常放置在HTTP请求的Authorization头中，格式为Bearer <token>，也可能出现在Cookie、URL参数或POST请求体中。可通过Base64解码快速识别：三个Base64字符串通过点号分隔，且第二部分解码后为JSON格式。

二、JWT安全风险全景

由于JWT的无状态特性，任何验证逻辑上的疏漏都可能导致攻击者完全控制认证过程。常见风险包括：

· 签名验证缺陷：服务器未正确验证签名，或允许空签名（alg=none）。
· 弱密钥：使用简单或公开的密钥，导致可被爆破。
· 算法混淆：强制将非对称算法降级为对称算法，利用公钥作为对称密钥。
· Header参数注入：通过jwk、jku、kid等字段引入外部不可信数据，实现签名伪造。
· 信息泄露：Payload明文存储密码、密钥等敏感信息。
· 令牌固定与过期失效：exp声明缺失或未校验，导致令牌永久有效。
· 注入攻击：kid等字段未过滤，引发路径遍历或SQL注入。

下面我们将结合理论与实践，逐一剖析这些攻击手法。

三、攻击技术详解与实战

3.1 空算法攻击（alg: none）

原理：JWT标准允许alg字段值为none，表示无签名。若服务器端验证逻辑未强制要求签名，攻击者可将Header中的alg改为none，并删除Signature部分，即可伪造任意用户。

实践步骤：

1. 捕获包含JWT的请求，解码Header，将alg修改为none（注意大小写变种：None、NONE）。
2. 删除签名部分（保留点号），即令牌变为header.payload.。
3. 重放请求，若服务器接受该令牌并返回正常响应，则存在漏洞。

工具：使用jwt_tool的-X a参数可快速生成空算法令牌。

3.2 签名缺失攻击（未验证签名）

原理：某些实现错误地认为JWT必须包含签名，但并未对签名进行校验，直接信任Header和Payload。攻击者可任意修改Payload后，保留原签名或留空，仍能通过验证。

实践：直接在JWT.io上修改Payload字段（如将user改为admin），重新编码后替换原令牌，若请求成功则存在漏洞。

3.3 弱签名密钥爆破

原理：如果JWT使用对称算法（如HS256）且密钥过于简单，攻击者可通过暴力破解或字典攻击还原密钥，从而任意伪造令牌。

实践：

1. 获取一个有效JWT，提取Header和Payload，得到签名原始数据。
2. 使用工具如hashcat或jwt_tool的字典爆破模式。
   ```bash
   jwt_tool <JWT> -C -d /path/to/dictionary.txt
   ```
3. 爆破成功后，用得到的密钥重新签名任意Payload。

注意：若密钥为公开信息（如常见框架默认密钥），则风险极高。

3.4 算法混淆攻击（RS256 → HS256）

原理：当服务器支持多种算法时，攻击者可将alg从非对称算法（如RS256）改为对称算法（HS256）。若服务器未验证算法类型，将使用公钥（通常公开）作为HS256的对称密钥进行验证，导致攻击者能用公钥签名有效令牌。

实践步骤（以Python为例）：

1. 获取服务器公钥（通常位于/jwks.json或/.well-known/jwks.json）。
2. 修改JWT的Header，将alg改为HS256，Payload改为目标用户。
3. 使用公钥作为HMAC密钥对令牌签名。
   ```python
   import jwt
   public_key = open('public.key', 'r').read()
   token = jwt.encode({'user':'admin'}, key=public_key, algorithm='HS256')
   ```
4. 将生成的令牌发送至服务器，若验证通过则攻击成功。

防御：严格限制算法类型，拒绝算法切换。

3.5 Header参数注入攻击

3.5.1 JWK注入（jwk header）

原理：Header中的jwk字段可嵌入一个JSON Web Key（公钥）。若服务器信任该内嵌公钥并用于验证签名，攻击者可自建密钥对，将公钥放入jwk，并用对应私钥签名令牌，从而绕过验证。

实践：使用jwt_tool的-X i参数自动生成带jwk的恶意令牌。

3.5.2 JKU注入（jku header）

原理：jku字段指定一个URL，服务器应从该URL获取JWK Set。若URL可被攻击者控制，则可搭建一个恶意JWK Set端点，返回攻击者的公钥。

实践：

1. 生成自签名RSA密钥对，并将公钥以JWK格式托管在可控服务器（如http://attacker.com/jwks.json）。
2. 修改JWT Header，将jku指向该URL，alg设为RS256。
3. 用私钥签名令牌，发送请求。若服务器从指定URL获取公钥并验证，则攻击成功。

3.5.3 KID注入（kid header）

原理：kid用于标识服务器端使用的密钥。若服务器根据kid从文件系统或数据库读取密钥，且未对输入进行过滤，则可能导致路径遍历或SQL注入。

路径遍历：

· 修改kid为../../../../dev/null或/etc/passwd，期望服务器读取该文件作为密钥，由于内容不可预测，可能使签名验证失败，但若配合其他漏洞（如空签名）或用于探测，可造成信息泄露。
· 更严重的是，若服务器能从文件系统读取攻击者可控的内容（如上传的文件），则可将kid指向该文件，实现任意密钥注入。

SQL注入：若kid用于查询数据库中的密钥，且未参数化，则可注入SQL语句提取密钥。

实践：使用jwt_tool的-T选项修改kid值，观察服务器响应。

3.6 信息泄露与时效性问题

· 信息泄露：解码Payload，检查是否包含密码、私钥等敏感字段。若存在，可直接利用。
· 时效性：查看Payload中是否存在exp声明，若无，则令牌永久有效。若有，将exp修改为未来时间戳，观察是否继续生效。

3.7 其他注入：通过错误回显探测

修改Payload中的键值对（如user->admin'），观察服务器返回的错误信息，可能发现SQL注入或NoSQL注入的迹象。

四、常用工具介绍

4.1 Burp Suite插件

· JSON Web Tokens：自动解析、高亮显示JWT，并提供修改重放功能。
· JWT Editor：支持签名、密钥管理，可轻松修改Header和Payload并重新签名。
· Hae：一款辅助检测JWT漏洞的Burp插件。

4.2 在线工具

· jwt.io：在线解码、验证、生成JWT，适合快速调试。

4.3 专用扫描与利用工具

· jwt_tool：功能强大的JWT安全测试工具，支持多种攻击模式（空算法、算法混淆、密钥爆破、Header注入等）。
· Venom-JWT：自动化检测与利用框架。
· jwt-scanner：被动扫描器。
· jwt-secrets：常见JWT密钥字典。

五、实战演练：从实验室到真实目标

我们以PortSwigger的Web安全学院实验室为例，演示典型攻击流程。

实验室1：通过未验证的签名绕过JWT身份验证

场景：某应用使用JWT进行身份验证，但服务器未验证签名。

步骤：

1. 登录获取JWT，解码Header发现alg为HS256。
2. 修改Payload中username为administrator。
3. 移除签名部分（保留最后一个点号），形成header.payload.。
4. 替换原Token发送请求，成功获取管理员权限。

实验室3：通过弱签名密钥绕过JWT身份验证

场景：JWT使用HS256，但密钥是简单字符串（如secret）。

步骤：

1. 捕获JWT，使用jwt_tool的字典爆破模式破解密钥。
   ```bash
   jwt_tool eyJhbG... -C -d rockyou.txt
   ```
2. 爆破得到密钥后，修改Payload为admin，用密钥重新签名。
3. 重放请求，成功越权。

实验室5：通过jku标头注入绕过JWT身份验证

场景：服务器支持jku头，从指定URL获取JWK Set。

步骤：

1. 生成RSA密钥对，将公钥转换为JWK格式，并上传至自己服务器（http://evil.com/jwks.json）。
2. 使用私钥生成一个JWT，Header中设置jku为http://evil.com/jwks.json，alg为RS256，Payload改为目标用户。
3. 发送请求，服务器从evil.com获取公钥并验证签名，攻击成功。

实验室6：通过kid头路径遍历绕过JWT身份验证

场景：服务器根据kid从文件系统读取密钥文件。

步骤：

1. 发现服务器存在文件上传功能，上传一个包含自定义内容的文件，获取路径如/uploads/evil.txt，内容为攻击者控制的密钥（例如aaaaaa）。
2. 修改JWT Header，将kid设置为../../uploads/evil.txt，使服务器读取该文件作为密钥。
3. 使用该密钥（aaaaaa）对修改后的Payload签名。
4. 请求成功，绕过验证。

六、防御措施

1. 严格验证签名：必须验证签名，拒绝alg: none及无签名的令牌。
2. 固定算法白名单：只允许一种强算法（如RS256），并验证alg与预期一致，防止算法混淆。
3. 安全存储密钥：使用高熵密钥，定期更换，避免硬编码。
4. 禁用不安全Header参数：如非必要，禁用jwk、jku、kid等可被外部控制的字段；若必须使用，应对输入进行严格校验（如URL白名单、路径过滤）。
5. 校验Payload声明：始终检查exp（过期时间）、aud（受众）等声明，防止令牌滥用。
6. 敏感数据不放入Payload：即使Base64编码也不是加密，避免存放密码、密钥等。
7. 使用标准的JWT库：避免自行实现验证逻辑，选择经过安全审计的库，并保持更新。
8. 监控与日志：记录异常的JWT使用行为（如大量失败验证、非常见alg）。

七、总结

JWT作为一种无状态认证机制，在提升系统扩展性的同时，也引入了新的攻击面。从空算法绕过到密钥爆破，从算法混淆到Header注入，每一种漏洞背后都是对JWT规范理解不深或实现不当的体现。作为安全人员，我们需要深入理解JWT的构成与潜在风险，熟练运用各类检测工具，在渗透测试中全面评估JWT的安全性。作为开发者，则应当遵循最佳实践，严格验证每一个环节，才能确保JWT这一“令牌”真正成为安全的通行证。

参考文献

· PortSwigger Web Security Academy: JWT attacks
· jwt.io
· jwt_tool GitHub repository
· 各类安全博客文章（详见文中引用）
