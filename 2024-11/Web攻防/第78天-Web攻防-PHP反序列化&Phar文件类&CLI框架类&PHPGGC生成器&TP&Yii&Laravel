引言

PHP反序列化漏洞一直是Web安全领域的“兵家必争之地”。从早期简单的__wakeup绕过，到如今复杂的POP链构造、原生类滥用以及字符串逃逸技术，攻击者与防御者的博弈不断推动着这一领域的进化。本文将以具体漏洞案例为线索，系统梳理PHP反序列化漏洞的核心机制与进阶利用技巧，帮助读者建立“从原理到实战”的完整认知。

一、基石：序列化与魔术方法

1.1 序列化机制

PHP通过serialize()将对象转换为可存储/传输的字符串，unserialize()则逆向还原对象。例如：

```php
class User {
    public $name = "admin";
    private $pwd = "123";
}
echo serialize(new User()); 
// O:4:"User":2:{s:4:"name";s:5:"admin";s:9:"Userpwd";s:3:"123";}
```

1.2 魔术方法的触发规则

PHP对象生命周期中的特定时刻会自动调用魔术方法，这为反序列化利用提供了“钩子”：

方法 触发时机
__construct() 对象创建时
__destruct() 对象销毁时
__wakeup() 反序列化恢复对象前
__toString() 对象被当作字符串时
__call() / __get() / __set() 访问不可访问成员时

漏洞成因：当反序列化的输入完全可控时，攻击者可以构造恶意序列化数据，在对象还原过程中触发危险魔术方法，进而劫持程序流程。

二、进阶利用：POP链与原生类

2.1 POP链的构造艺术

POP（Property-Oriented Programming）链通过串联多个类的魔术方法，形成从入口点（如__destruct）到敏感函数（如eval、file_put_contents）的调用路径。

典型场景：某CMS的反序列化入口处，通过寻找同名方法或属性跳转，最终达成任意文件写入。

2.2 原生类的“意外之喜”

PHP内置类在反序列化时同样可能被滥用，实现特定攻击效果：

· Exception：利用其__toString输出错误信息，可构造XSS：
  ```php
  $xss = new Exception("<script>alert(1)</script>");
  echo serialize($xss);
  ```
· SoapClient：触发__call方法发起SSRF请求。
· SimpleXMLElement：通过构造实体注入产生XXE。

这些原生类无需依赖业务代码，为攻击者提供了“即插即用”的武器库。

三、变量属性与跨版本解析差异

3.1 属性可见性的序列化特征

不同作用域的属性在序列化字符串中有特殊标记：

· public：s:4:"name"
· protected：s:7:"\0*\0age"（\0即%00）
· private：s:12:"\0ClassName\0pwd"

3.2 版本差异导致的绕过

案例：[网鼎杯 2020 青龙组] AreUSerialz

题目源码包含is_valid()函数，要求反序列化字符串中的所有字符ASCII码在32-125之间。但protected/private属性的序列化包含不可打印的\0（ASCII 0），直接违反校验。

突破思路：PHP 7.1+ 版本对属性可见性的序列化方式发生改变——无论声明为protected还是private，如果对象属性在序列化时实际为public，将按public格式存储。因此只需将属性全部设为public，即可绕过字符检测：

```php
public $op = 2;
public $filename = "php://filter/read=convert.base64-encode/resource=flag.php";
public $content;
```

此案例揭示了版本演进对反序列化攻击面的深远影响，攻击者需时刻关注环境差异。

四、经典版本绕过：CVE-2016-7124（__wakeup）

4.1 漏洞原理

在PHP 5 < 5.6.25、PHP 7 < 7.0.10中，当反序列化字符串中表示对象属性个数的值大于实际属性个数时，__wakeup()方法不会被调用。

```php
// 正常序列化
O:4:"Name":2:{...}
// 攻击载荷：将属性个数改为3
O:4:"Name":3:{...} // 绕过__wakeup
```

4.2 实战：[极客大挑战 2019] PHP

题目提供了源码备份，反序列化入口为select参数，存在__wakeup()强制将username重置为“guest”，而读取flag需要username === "admin"。

Payload构造：

```php
class Name {
    public $username = "admin";
    public $password = "100";
}
// 序列化后得到：O:4:"Name":2:{s:14:"%00Name%00username";s:5:"admin";s:14:"%00Name%00password";s:3:"100";}
// 将属性个数改为3
O:4:"Name":3:{s:14:"%00Name%00username";s:5:"admin";s:14:"%00Name%00password";s:3:"100";}
```

URL编码后传入，成功绕过__wakeup()，获取管理员权限。

该漏洞虽古老，但至今仍大量存在于低版本PHP环境中，是反序列化入门必学的一课。

五、字符串逃逸：字符增减的攻防博弈

5.1 原理概述

当反序列化字符串经过过滤函数（如替换、截断）后，若长度发生变化，可能破坏原有结构，攻击者可借此“吞掉”或“挤出”后续属性。

字符变多（替换增长）

```php
$str = str_replace('x', 'xx', $serialized);
// 序列化字符串变长，后续内容被“挤”出，需用填充补位
```

CTFSHOW-Web262：本地测试发现序列化字符串长62位，利用字符增多覆盖后续的token校验。

字符变少（替换缩短）

```php
$str = str_replace('xx', 'x', $serialized);
// 长度减少，后续字符串向前移动，可闭合引号注入新属性
```

5.2 实战：CTFSHOW-Web262（逃逸解法）

题目通过message.php接收msg参数并反序列化，要求token属性值为“admin”。但反序列化前存在字符串替换，将message变为msg（长度减少1）。

构造思路：

1. 本地序列化一个包含token=admin的对象，计算其字符串长度。
2. 利用替换减少的长度差，通过填充多个被替换关键词，使反序列化解析时，token的值被截断并重新赋值。

逃逸技术是反序列化攻击从“直接利用”转向“逻辑构造”的典型代表，充分体现了PHP序列化格式的脆弱性与灵活性。

六、防御体系构建

1. 严格限制反序列化输入：避免用户可控参数传入unserialize()，如必须使用，则应对字符串进行签名验证或采用白名单类限制。
2. 升级PHP版本：及时修复CVE-2016-7124等已知漏洞，并利用新版本对序列化格式的改进。
3. 禁用危险原生类：通过disable_classes禁用SoapClient、SimpleXMLElement等可能被滥用的类。
4. 代码审计：重点关注__wakeup、__destruct等魔术方法中的敏感操作，以及属性赋值导致的跳转。

结语

PHP反序列化漏洞如同一场永不落幕的攻防实验。从最初的魔术方法触发，到复杂的POP链构造，再到版本差异与字符串逃逸，攻击者不断在有限规则下挖掘无限可能。理解这些技术的本质——序列化格式与PHP内部处理逻辑的碰撞——方能做到“攻守有道”。无论是白盒审计还是黑盒测试，这份理论与实践结合的知识图谱，都将成为Web安全研究者手中的利器。
