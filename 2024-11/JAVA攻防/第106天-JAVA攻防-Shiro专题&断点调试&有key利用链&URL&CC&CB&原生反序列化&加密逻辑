Java作为企业级应用开发的主流语言，其生态丰富、框架众多，但也因此引入了复杂的安全风险。从常规的SQL注入、XXE到反序列化、JNDI注入，Java安全一直是攻防演练中的重点。本文将结合理论与实践，深入剖析Java常见漏洞的形成原理、审计方法及利用技巧，帮助读者构建系统的Java安全知识体系。

---

一、Java常规漏洞审计与利用

1. SQL注入

Java后端与数据库交互的方式多样，注入风险主要源于拼接SQL语句。

· JDBC层：
  · Statement直接拼接：危险。
  · PreparedStatement预编译：安全，但若开发者仍使用字符串拼接方式构造SQL（如 "select * from user where id = "+id），预编译机制被绕过，依然存在注入。
  · JdbcTemplate：Spring对JDBC的封装，若使用字符串拼接同样存在注入。
  · 安全写法：使用占位符（?） + PreparedStatement预编译。
· MyBatis框架：
  · #{}：预编译，安全。
  · ${}：字符串拼接，不安全。
  · 典型注入场景：
    · order by注入：order by #{col}会变成order by 'col'导致语法错误，开发者常改用${col}造成注入。
    · like查询：'%#{q}%'会报错，若改为'%${q}%'则引入注入。
    · in查询：id in (#{ids})无法处理多个值，若用${ids}拼接则可能注入。
· Hibernate/JPA：使用命名参数如:username或setParameter可有效防止注入。

白盒审计要点：

1. 确定持久层技术（JDBC、MyBatis等）。
2. 查找SQL操作代码，检查参数拼接方式。
3. 重点关注order by、like、in等特殊场景。

2. XXE注入

XML外部实体注入（XXE）常出现在解析XML文档的功能中。Java中处理XML的类众多，若未禁用外部实体，则可能被利用。

审计Sink点（常见XML解析类）：

· XMLReader、SAXReader、DocumentBuilder、SAXParser、SAXBuilder、TransformerFactory、SchemaFactory、Unmarshaller、XPathExpression等。

实践检测：检查上述类在parse方法调用时，是否对外部实体进行了禁用配置（如setFeature("http://apache.org/xml/features/disallow-doctype-decl", true)）。

3. RCE（命令执行）

Java中执行系统命令的常见类：

· Runtime.getRuntime().exec()
· ProcessBuilder
· ProcessImpl（底层实现）
· GroovyShell（若传入未经过滤的表达式）

审计：查找以上类实例化及参数传递的位置，确认参数是否可控。

4. SSRF与URL跳转

· SSRF：常由URL类发起网络请求，若url参数可控，可能导致内网探测或端口扫描。
· URL跳转：Spring MVC中通过ModelAndView设置redirect:前缀，或HttpServletResponse.sendRedirect()、ResponseEntity设置Location头。若重定向目标由用户控制，可导致钓鱼或恶意跳转。

---

二、表达式注入与框架安全

1. SSTI（服务器模板注入）

当用户输入被直接拼接到模板引擎中渲染时，可能注入模板指令，导致RCE。常见的Java模板引擎：

· Thymeleaf：可通过${...}执行表达式。
· Velocity、Freemarker：同样支持表达式解析。

审计：查找模板渲染函数（如template.process），检查参数是否来自用户输入且未经过滤。

2. SpEL表达式注入

Spring Expression Language（SpEL）功能强大，若将用户输入直接传递给SpelExpressionParser.parseExpression()，可导致表达式注入，进而执行任意代码或绕过反射限制。

案例：@Value注解中若使用动态表达式且未校验来源，可能被利用。

3. Swagger API接口泄露

Swagger未正确配置访问控制，可能导致API接口文档泄露，攻击者可借此发现敏感接口并进行攻击。

发现：扫描器识别/swagger-ui.html、/v2/api-docs等路径。
利用：导入到Apifox等工具，批量测试接口漏洞。

4. Spring Boot Actuator泄露

Actuator提供了生产级监控端点，若未做访问控制，可能泄露敏感信息。

关键端点：

· /actuator/health、/actuator/info：信息泄露。
· /actuator/env、/actuator/configprops：配置信息（含密码）。
· /actuator/heapdump：堆转储文件，可提取内存中的敏感数据。

Heapdump利用工具：

· JDumpSpider
· heapdump_tool
· JDumpSpiderGUI

通过分析heapdump，可提取数据库密码、接口密钥等。

---

三、Java反序列化漏洞深度剖析

反序列化漏洞是Java安全的“重灾区”，其本质是应用从输入流中恢复对象时，未对数据来源做校验，导致攻击者构造恶意对象触发危险方法。

1. 原生反序列化

Java原生序列化机制通过ObjectOutputStream.writeObject()将对象转为字节流，通过ObjectInputStream.readObject()重建对象。若readObject()的输入可控，攻击者可构造Gadget链（如CommonsCollections）实现RCE。

其他原生反序列化接口：

· SnakeYaml：Yaml.load()，支持YAML格式的反序列化。
· XMLDecoder：readObject()，可解析XML内容。
· XStream：fromXML()。

审计Sink点：

· ObjectInputStream.readObject()
· XMLDecoder.readObject()
· Yaml.load()
· XStream.fromXML()
· ObjectMapper.readValue()（Jackson）
· JSON.parse() / JSON.parseObject()（Fastjson）
· CookieRememberMeManager（Shiro）
· logger.error / logger.info（Log4j）

2. 三方组件反序列化历史漏洞

组件 典型触发方法 常用利用链
Log4j logger.error(msg, params) JNDI注入（CVE-2021-44228）
Shiro Cookie中rememberMe字段 AES解密后反序列化，依赖CC/CB链
Jackson readValue() 多态类型处理（enableDefaultTyping）
XStream fromXML() 历史漏洞（如CVE-2013-7285）
Fastjson parseObject() / parse() 各版本链分析（JdbcRowSetImpl等）

3. JNDI注入与高版本绕过

JNDI（Java命名和目录接口）允许通过名称查找对象，支持RMI、LDAP等协议。早期版本中，攻击者可利用远程Codebase加载恶意类，触发RCE。

JDK版本限制演进：

· JDK 6u45/7u21：java.rmi.server.useCodebaseOnly默认true，禁止RMI远程加载。
· JDK 6u141/7u131/8u121：com.sun.jndi.rmi.object.trustURLCodebase默认false，禁止RMI远程Codebase。
· JDK 6u211/7u201/8u191：com.sun.jndi.ldap.object.trustURLCodebase默认false，禁止LDAP远程Codebase。

高版本绕过思路：

1. 本地Reference链：利用本地已有的类作为Factory。
2. 反序列化链：LDAP返回javaSerializedData字段，若本地存在反序列化Gadget（如CC链），仍可触发RCE。
3. 利用中间件/依赖包：某些组件（如Tomcat）内置了可利用的类，可通过本地ClassPath绕过。

自动化工具：

· JYso
· JNDIMap
· JNDI-Injection-Exploit-Plus
· java-chains

4. FastJson各版本利用链分析

FastJson是一款高性能JSON库，其反序列化漏洞主要源于AutoType功能允许指定类名，配合getter/setter调用触发恶意逻辑。

常见利用链

· 1.2.24及以下：JdbcRowSetImpl JNDI注入（需开启trustURLCodebase）。
· 1.2.25-1.2.47：需要开启AutoType或绕过黑名单，可利用TemplatesImpl、BCEL等链。
· 1.2.48-1.2.80：黑名单不断扩充，利用需依赖特定Gadget（如c3p0、commons-io等）。
· 1.2.80+：官方进一步修复，但仍可能存在绕过。

核心Gadget

· JdbcRowSetImpl（JDK自带）：通过dataSourceName + autoCommit触发JNDI lookup。
· TemplatesImpl：需开启SupportNonPublicField，通过_bytecodes加载字节码。
· BCEL（Tomcat/Spring场景）：利用org.apache.tomcat.dbcp.dbcp2.BasicDataSource + com.sun.org.apache.bcel.internal.util.ClassLoader执行BCEL字节码。
· c3p0：通过WrapperConnectionPoolDataSource的userOverridesAsString属性传入Hex序列化数据，触发本地反序列化。

黑盒测试要点

1. 识别FastJson：通过报错信息（如com.alibaba.fastjson.JSONException）或响应头（如fastjson字段）。
2. 判断版本：使用{"@type":"java.lang.AutoCloseable"}等技巧触发不同异常，推断版本范围。
3. 测试JNDI延时：{"@type":"com.sun.rowset.JdbcRowSetImpl","dataSourceName":"rmi://127.0.0.1:1099/xxx","autoCommit":true}观察响应时间。
4. 使用通用Payload进行测试，并结合工具（如Yakit、JYso）生成针对性链。

5. Shiro反序列化（RememberMe）

Shiro框架的CookieRememberMeManager默认使用AES加密（硬编码密钥kPH+bIxk5D2deZiIxcaaaA==）对rememberMe cookie进行Base64解码后反序列化。

漏洞原理：

1. 获取rememberMe cookie。
2. Base64解码。
3. AES解密（密钥已知）。
4. 反序列化。

由于密钥硬编码，攻击者可构造恶意序列化对象，加密后放入cookie，触发反序列化漏洞。

利用链选择：

· Shiro依赖于原生反序列化，因此需使用ysoserial中的链（如CommonsCollections、CommonsBeanutils等）。
· 注意：不能使用FastJson的JdbcRowSetImpl链，因为Shiro触发的是readObject，而非getter/setter。

工具：

· ysoserial生成Payload，再用Shiro自带密钥加密并Base64编码。
· 自动化工具：shiro_tool、java-chains等。

实战步骤：

1. 检测是否存在Shiro：响应头有rememberMe=deleteMe。
2. 爆破密钥（若默认密钥修改）。
3. 选择合适的Gadget（根据目标依赖库）。
4. 加密并发送Payload。

---

四、自动化工具与靶场资源

靶场推荐

· JavaSec
· JavaSecLab
· Hello-Java-Sec

利用工具

· Yakit：集成多种Java漏洞检测插件。
· JYso：支持JNDI注入、反序列化链生成。
· ysoserial：经典的反序列化Payload生成工具。
· java-chains：可视化生成多种Java漏洞Payload。
· JNDI-Injection-Exploit：JNDI注入利用工具。
· JDumpSpider：Spring Boot Heapdump敏感信息提取。

---

五、总结与学习建议

Java安全涉及面广，从基础代码审计到高级反序列化利用，需要循序渐进：

1. 打好基础：掌握Java反射、动态代理、类加载机制。
2. 理解漏洞原理：从原生反序列化开始，逐步深入三方组件（FastJson、Shiro）的漏洞成因。
3. 动手实践：在靶场环境中调试漏洞，分析利用链源码。
4. 关注最新绕过技术：高版本JDK下的JNDI绕过、新Gadget的挖掘。

本文通过梳理Java常见漏洞的审计点与利用方法，希望能为读者构建一个完整的Java安全知识框架。在实际攻防中，灵活结合理论与实践，方能发现并修复深层次的安全问题。

注：所有技术讨论仅限于安全研究和授权测试，请勿用于非法用途。
