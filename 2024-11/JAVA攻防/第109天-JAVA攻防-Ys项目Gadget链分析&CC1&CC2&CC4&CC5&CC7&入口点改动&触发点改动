1. 引言

Java作为企业级应用开发的主流语言，其生态庞大、组件丰富，但也因此引入了多样化的安全风险。从传统的Web漏洞（SQL注入、XXE、RCE）到框架特有的表达式注入、反序列化漏洞，再到JNDI注入与高版本绕过，Java安全领域一直是攻防研究的焦点。本文将从理论原理出发，结合代码审计与实战利用，系统梳理Java安全的核心漏洞类型、利用链构造思路以及防御方法，帮助读者构建完整的Java安全知识体系。

2. Java Web常规漏洞分析

2.1 SQL注入

原理：当应用程序将用户输入直接拼接到SQL语句中，且未经过滤或预编译时，攻击者可操控SQL逻辑。

常见数据库交互技术及安全写法：

技术 不安全写法示例 安全写法
JDBC Statement stmt = conn.createStatement(); stmt.executeQuery("SELECT * FROM user WHERE id=" + id); PreparedStatement ps = conn.prepareStatement("SELECT * FROM user WHERE id=?"); ps.setInt(1, id);
MyBatis ${param} 拼接（如order by、like、in场景） #{param} 预编译，order by需白名单校验，like使用CONCAT('%',#{q},'%')
Hibernate 拼接HQL或SQL 命名参数 :username + setParameter
JPA 拼接JPQL 命名参数 :username + setParameter

审计要点：

· 确定使用的数据库中间件（JDBC / MyBatis / Hibernate等）。
· 定位SQL语句构造处，检查是否存在参数拼接。
· 重点关注order by、like、in等难以直接预编译的场景，查看是否采用白名单或特殊处理。

2.2 XXE注入

原理：XML处理器未禁用外部实体解析，导致攻击者可读取本地文件、发起SSRF等。

常见XML解析库及审计函数（共12类）：

```
XMLReader.parse()、SAXReader.parse()、DocumentBuilder.parse()、
XMLStreamReader.next()、SAXBuilder.build()、SAXParser.parse()、
SAXSource、TransformerFactory、SAXTransformerFactory、
SchemaFactory、Unmarshaller、XPathExpression
```

审计方法：搜索上述函数调用，检查parse方法的输入是否可控，以及是否设置了安全的解析特性（如setFeature("http://apache.org/xml/features/disallow-doctype-decl", true)）。

2.3 RCE执行

常见执行函数：

· Runtime.getRuntime().exec(cmd)
· new ProcessBuilder(cmd).start()
· ProcessImpl（底层实现）
· GroovyShell.evaluate(code)

审计点：查找这些函数的调用，追踪参数是否来源于用户输入，并检查是否存在过滤/转义。

2.4 SSRF

核心类：java.net.URL。当攻击者可控制URL时，可发起内网请求。

审计点：new URL(userInput)后调用openConnection()或openStream()。

2.5 URL跳转

常见实现：

· Spring MVC：return "redirect:" + userInput;
· Servlet API：response.sendRedirect(userInput);
· Spring ResponseEntity设置Location头。

安全风险：未校验跳转地址导致开放重定向，可配合钓鱼攻击。

3. 模板注入与表达式注入

3.1 SSTI（服务器模板注入）

当模板内容中包含用户输入且未正确转义时，攻击者可注入模板表达式执行任意代码。

常见Java模板引擎：

· Thymeleaf：默认HTML转义，但若使用th:text或内联[[...]]且未转义，可能导致表达式执行。
· Velocity：#set、$!{}等语法，若用户可控制模板内容，则直接RCE。
· Freemarker：${...}表达式，若未开启沙箱或配置不当，可执行任意代码。

防御：避免用户控制模板内容；使用安全的配置（如Freemarker的Configuration.setNewBuiltinClassResolver(TemplateClassResolver.SAFER_RESOLVER)）。

3.2 SPEL表达式注入

Spring表达式语言（SpEL）常用于注解、XML配置等。若用户输入直接传递给SpelExpressionParser.parseExpression()并执行，可导致RCE。

审计点：new SpelExpressionParser().parseExpression(userInput).getValue()。

利用示例：T(java.lang.Runtime).getRuntime().exec("calc")。

4. SpringBoot框架安全

4.1 信息泄露

· Swagger接口文档泄露：未授权访问/swagger-ui.html或/v2/api-docs，可获取所有API端点，进而攻击。
· Actuator端点泄露：/actuator未限制访问，可获取/env、/heapdump、/jolokia等敏感信息。

工具扫描：

· SBSCAN
· spring-scan
· SpringBootVul-GUI

4.2 Heapdump分析

/actuator/heapdump可下载JVM堆内存快照，其中可能包含数据库密码、API密钥等敏感信息。

分析工具：

· JDumpSpider
· heapdump_tool
· JDumpSpiderGUI

5. Java反序列化漏洞专题

5.1 原生反序列化

原理：ObjectInputStream.readObject()在反序列化时会调用对象的readObject()方法，若链中存在危险类（如TemplatesImpl、JdbcRowSetImpl），则可能RCE。

其他原生反序列化接口：

· SnakeYaml.load()：解析YAML时可执行任意代码。
· XMLDecoder.readObject()：XML解码器可构造恶意XML执行代码。

5.2 三方组件反序列化

组件 审计Sink点 历史漏洞
Log4j logger.error(message)（JNDI注入） CVE-2021-44228 (Log4Shell)
Shiro CookieRememberMeManager（rememberMe） Shiro-550、Shiro-721
Jackson ObjectMapper.readValue() 多版本反序列化（CVE-2019-12384等）
XStream XStream.fromXML() 多个高危漏洞（CVE-2021-21346等）
FastJson JSON.parse() / JSON.parseObject() 1.2.24~1.2.80多版本Gadget链

6. JNDI注入深入

6.1 JNDI基础

JNDI（Java命名和目录接口）支持RMI、LDAP、DNS等协议。攻击者可通过控制JNDI的lookup参数，指向恶意RMI/LDAP服务器，返回恶意Reference对象，导致远程类加载。

6.2 JDK版本限制与绕过

JDK版本 限制行为 绕过思路
6u45 / 7u21 之后 java.rmi.server.useCodebaseOnly 默认true，禁止远程加载类（RMI）。 本地CLASSPATH中存在可利用类（如Tomcat中的org.apache.naming.factory.BeanFactory）
6u141 / 7u131 / 8u121 之后 com.sun.jndi.rmi.object.trustURLCodebase 默认false，RMI无法远程加载。 LDAP协议仍可远程加载（trustURLCodebase仍为true）
6u211 / 7u201 / 8u191 之后 com.sun.jndi.ldap.object.trustURLCodebase 默认false，LDAP也无法远程加载。 利用LDAP的javaSerializedData属性返回序列化数据，触发本地Gadget链反序列化。

实战工具：

· JYso
· JNDIMap
· JNDI-Injection-Exploit-Plus

7. FastJson反序列化专题

7.1 基础与漏洞原理

FastJson通过@type指定反序列化类，并自动调用setter/getter。攻击者可构造恶意JSON触发JNDI或直接执行代码。

核心方法：

· JSON.parseObject(json, Object.class)：默认开启@type，调用setter和getter。
· JSON.parse(json)：也支持@type，但仅调用setter。

7.2 各版本利用链

版本范围 典型Gadget 说明
1.2.24及以下 JdbcRowSetImpl + JNDI 经典链，autoCommit触发lookup。
1.2.25~1.2.47 开启AutoType + JdbcRowSetImpl 或 依赖包 需开启AutoType，或利用java.lang.Class绕过（1.2.47版本存在特殊绕过）
1.2.48~1.2.80 依赖包Gadget（如BasicDataSource BCEL） 需要AutoType开启，且存在相关依赖（Tomcat、Spring、c3p0等）。
1.2.80之后 暂无公开RCE链，但可能存在绕过 官方不断修复，需关注最新进展。

7.3 不出网利用链

当目标无法外连时，可使用本地类加载或反序列化链：

· TemplatesImpl链（需开启Feature.SupportNonPublicField）：
  ```json
  {
      "@type": "com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl",
      "_bytecodes": ["base64编码的字节码"],
      "_name": "a.b",
      "_tfactory": {},
      "_outputProperties": {}
  }
  ```
· BCEL链（依赖Tomcat或Spring的BasicDataSource）：
  ```json
  {
      "@type": "org.apache.tomcat.dbcp.dbcp2.BasicDataSource",
      "driverClassLoader": {
          "@type": "com.sun.org.apache.bcel.internal.util.ClassLoader"
      },
      "driverClassName": "$$BCEL$$xxxx"
  }
  ```
· c3p0链（需c3p0依赖）：
  ```json
  {
      "@type": "java.lang.Class",
      "val": "com.mchange.v2.c3p0.WrapperConnectionPoolDataSource"
  },
  "f": {
      "@type": "com.mchange.v2.c3p0.WrapperConnectionPoolDataSource",
      "userOverridesAsString": "HexAsciiSerializedMap:;HEX序列化数据"
  }
  ```

7.4 黑盒测试

1. 检测是否使用FastJson：发送异常JSON（如{"@type":"java.lang.Class"}）观察报错。
2. 测试延时：{"@type":"com.sun.rowset.JdbcRowSetImpl","dataSourceName":"rmi://127.0.0.1:1099/xxx","autoCommit":true}，若服务端尝试连接，则存在漏洞。
3. 结合JNDI工具进行利用。

8. Shiro反序列化专题

8.1 漏洞原理

Shiro的RememberMe功能流程：

· 从Cookie获取rememberMe值。
· Base64解码。
· AES解密（默认密钥kPH+bIxk5D2deZiIxcaaaA==）。
· 反序列化。

攻击者使用默认密钥加密恶意Payload，即可触发反序列化漏洞。

8.2 利用链分析

入口：CookieRememberMeManager读取Cookie并反序列化。

Gadget构造：

· 可使用ysoserial中的CommonsCollections系列链。
· 但需注意：Shiro默认依赖commons-beanutils（CB），而非commons-collections（CC），因此需使用CB链。

CB链（BeanComparator + PriorityQueue）：

· 入口：PriorityQueue.readObject()
· 中间调用：PriorityQueue.siftDownUsingComparator() -> BeanComparator.compare() -> PropertyUtils.getProperty() -> TemplatesImpl.getOutputProperties()
· 执行点：TemplatesImpl.newTransformer() -> 加载恶意字节码。

构造要点：

· PriorityQueue初始化大小≥2。
· BeanComparator的property设为outputProperties。
· TemplatesImpl需设置_bytecodes、_name。

8.3 JRMP绕过

当无合适Gadget时，可利用JRMP反序列化：

· 攻击机启动JRMPListener，提供恶意Payload。
· Shiro端通过反序列化JRMPClient连接攻击机，获取远程Gadget。

工具：ysoserial的JRMPListener + Shiro利用工具（如java-chains的JRMP模式）。

9. CommonsCollections链分析

9.1 CC1：TransformedMap + LazyMap

调用链：

```
AnnotationInvocationHandler.readObject()
  -> LazyMap.get()
    -> ChainedTransformer.transform()
      -> ConstantTransformer.transform()
      -> InvokerTransformer.transform()（多次调用执行Runtime.exec）
```

9.2 CC2：PriorityQueue + InvokerTransformer + TemplatesImpl

调用链：

```
PriorityQueue.readObject()
  -> TransformingComparator.compare()
    -> InvokerTransformer.transform()
      -> TemplatesImpl.newTransformer()
```

9.3 CC4：PriorityQueue + InstantiateTransformer + TrAXFilter

与CC2类似，但使用InstantiateTransformer替代InvokerTransformer，通过TrAXFilter带参构造调用TemplatesImpl.newTransformer()。

9.4 CC5：BadAttributeValueExpException + LazyMap

调用链：

```
BadAttributeValueExpException.readObject()
  -> TiedMapEntry.toString()
    -> LazyMap.get()
      -> ChainedTransformer.transform()
```

9.5 CC7：Hashtable + LazyMap

利用Hashtable反序列化时的reconstitutionPut调用equals，触发LazyMap.get()。

10. 实战工具与靶场推荐

10.1 工具集

· Yakit：集成Java漏洞扫描与利用插件。
· ysoserial：经典反序列化Payload生成工具。
· java-chains：支持多种Gadget生成、JNDI服务器、JRMP等。
· JYso：一款集成了JNDI注入、反序列化生成、内存马注入的多功能工具。

10.2 靶场

· JavaSec
· JavaSecLab
· Hello-Java-Sec

11. 总结

Java安全涉及面广、链条复杂，但核心思路始终是：寻找可控输入点 -> 追踪数据流 -> 挖掘危险方法调用 -> 构造利用链。掌握代码审计的Sink点、理解各组件漏洞原理、熟悉常用工具，是深入研究Java安全的基础。随着JDK与组件版本的迭代，攻防技术也在不断演进，持续跟踪新漏洞与绕过技巧，方能立于不败之地。
