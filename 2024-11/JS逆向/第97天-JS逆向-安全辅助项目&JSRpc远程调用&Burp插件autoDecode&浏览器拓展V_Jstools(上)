引言：JS逆向与安全

JS逆向，通俗来讲，就是在浏览器调试器中，对前端代码（HTML、JS、CSS）进行分析，以理解其逻辑、获取路由、发现加密方式、挖掘敏感信息泄露等。其应用场景广泛且深入安全测试的方方面面：

· 登录框加密传输：对密码等字段进行前端加密，若未正确实现，可能导致爆破攻击失效或绕过。
· 电商折扣计算：前端计算折扣，攻击者可能篡改JS逻辑，修改价格。
· 验证码生成：若验证码生成逻辑可预测，则可绕过验证。
· 签名伪造：如某平台的X-Sign签名，逆向后可构造任意请求，实现未授权操作。
· 参数加密：逆向算法后修改Payload，测试服务端漏洞。

因此，掌握JS逆向不仅是安全研究者的必备技能，也是开发者保障前端安全的基础。本文将从开发者工具入手，逐步深入反调试、Hook、算法还原、签名绕过、代码混淆等核心领域，并结合大量真实案例，帮助读者构建完整的JS逆向知识体系。

---

一、开发者工具：逆向的基石

浏览器开发者工具（F12）是JS逆向最直观的战场。掌握其核心面板，能让后续分析事半功倍。

1.1 核心面板功能

· 网络（Network）：监控所有HTTP请求，查看请求参数、响应数据，是定位加密入口的起点。
· 源代码/来源（Sources）：查看所有加载的JS文件，可设置断点、查看作用域、调用堆栈。
· 控制台（Console）：动态执行JS代码，测试函数，输出调试信息。
· 元素（Elements）：查看DOM结构，有时可发现隐藏字段或注释中的敏感信息。

1.2 作用域与调用堆栈

· 作用域（Scope）：断点调试时，右侧Scope面板显示当前函数内的局部变量、闭包变量和全局变量。通过观察变量值变化，可快速定位加密参数生成过程。
· 调用堆栈（Call Stack）：展示函数调用的顺序，帮助我们回溯加密函数的源头。例如，在提交登录请求时，通过堆栈可找到密码加密的最终处理函数。

1.3 断点调试实战

以某应用登录接口为例：

1. 在Network中找到登录请求，定位到param加密参数。
2. 在Sources中搜索param关键词，找到相关代码行。
3. 下断点并重新触发请求，程序暂停后观察作用域中的变量，发现za(c.value, S)调用。
4. 进入函数za，分析其内部实现，识别出AES加密算法及模式（如CBC、ECB）。通过条件断点或逐步执行，最终还原加密逻辑。

参考链接：某应用断点调试详细步骤

---

二、反调试技术：对抗与绕过

为防止逆向分析，开发者常植入反调试代码。理解这些机制并掌握绕过技巧，是深入逆向的关键。

2.1 常见反调试手段

· 无限Debugger：通过setInterval或Function构造无限循环的debugger语句，使调试器持续中断。
· 键盘监听：监听F12、Ctrl+Shift+I等快捷键，禁用开发者工具。
· 检测窗口大小/高度：开发者工具打开时，窗口内外高度差会变化，通过检测此差异判断是否打开工具。
· 检测开发者工具变量：如console对象被修改、devtoolsopen等变量是否存在。
· 利用代码执行时间差：调试时代码执行速度变慢，通过计时检测。
· toString检测：检测函数是否被篡改（如Function.prototype.toString）。
· 检测非浏览器环境：如navigator.webdriver、navigator.plugins等属性。

2.2 绕过技巧

1. 禁用所有断点：在Sources面板中点击“Deactivate breakpoints”按钮，或按Ctrl+F8。
2. 禁用局部断点：右键断点选择“Remove breakpoint”，或设置条件断点使其不触发。
3. 替换文件执行：通过浏览器Overrides功能，将远程JS文件映射到本地修改后的文件，直接移除反调试代码。
4. Burp修改响应：拦截服务器返回的JS文件，删除反调试代码后再返回给浏览器。
5. 油猴插件+Hook：编写用户脚本，在页面加载前Hook反调试函数，使其失效。

2.3 案例：绕过无限Debugger

某网站使用如下代码防止调试：

```javascript
function enableDebugProtection() {
    var dbg = new Function("debugger");
    setInterval(dbg, 3000); // 每3秒触发一次debugger
}
```

绕过思路：使用油猴脚本Hook Function构造函数和setInterval。

```javascript
// ==UserScript==
// @name         Bypass Debugger
// @match        *://target.com/*
// @grant        none
// ==/UserScript==

(function() {
    // 拦截Function构造函数，若包含"debugger"则返回空函数
    const originalFunction = window.Function;
    window.Function = function(...args) {
        if (args.some(arg => arg.includes('debugger'))) {
            return function(){};
        }
        return originalFunction(...args);
    };
    // 拦截setInterval，若回调是debugger则忽略
    const originalSetInterval = window.setInterval;
    window.setInterval = function(callback, interval) {
        if (callback.toString().includes('debugger')) {
            return 0; // 返回一个假ID
        }
        return originalSetInterval(callback, interval);
    };
})();
```

更复杂的案例中，反调试代码可能隐藏在Function.prototype.constructor中，需针对性Hook。

---

三、Hook技术：动态插桩与行为修改

Hook（钩子）是一种拦截和修改JavaScript函数或对象行为的技术，广泛应用于动态分析、自动化测试和安全研究。

3.1 Hook开发基础

油猴脚本（Tampermonkey）是实现Hook的便捷工具。脚本头部需定义元信息：

```javascript
// ==UserScript==
// @name         脚本名称
// @namespace    作用域标识
// @version      版本号
// @description  描述
// @author       作者
// @match        匹配的URL规则
// @icon         图标
// @grant        特殊权限（如GM_xmlhttpRequest）
// ==/UserScript==
```

3.2 Hook原理

Hook的本质是替换原始函数，在调用前后插入自定义逻辑。例如，Hook JSON.stringify以查看序列化前的对象：

```javascript
const originalStringify = JSON.stringify;
JSON.stringify = function(obj) {
    console.log('Stringify called with:', obj);
    return originalStringify(obj);
};
```

3.3 实战案例：修改页面元素宽高

某页面检测窗口大小，当检测到开发者工具打开时，隐藏关键内容。我们可以Hook相关属性：

```javascript
Object.defineProperty(window, 'innerHeight', {
    get: function() { return 900; } // 固定值，绕过检测
});
```

3.4 实战案例：绕过Function构造函数型Debugger

某网站采用以下方式生成debugger：

```javascript
function() {}.constructor("debugger")()
```

Hook方案：

```javascript
const originalConstructor = Function.prototype.constructor;
Function.prototype.constructor = function(...args) {
    if (args[0] && args[0].includes('debugger')) {
        return function(){}; // 返回空函数
    }
    return originalConstructor.apply(this, args);
};
```

配合油猴脚本，在页面加载前注入，即可轻松绕过。

---

四、加密算法解密：扣代码与替代库

加密是JS逆向的核心难点。通过调用堆栈定位加密点后，通常有两种还原方式：扣代码直接调用，或使用替代库模拟。

4.1 定位加密点的方法

· 根据调用堆栈：提交请求时，在Network中右键请求 -> Copy -> Copy as fetch，然后在Sources中搜索相关URL，下XHR断点。触发请求后，观察调用堆栈，回溯加密函数。
· 根据参数名搜索：全局搜索参数名（如sign、param、encrypt），找到生成位置。

4.2 请求数据解密案例

案例1：某登录接口参数param加密。

· 在调用堆栈中找到za(c.value, S)，进入函数za，发现其为AES加密。
· 通过调试，确定密钥S的来源（硬编码或动态生成），以及加密模式（ECB、CBC）。
· 扣代码：将加密函数及相关依赖复制到本地Node环境，直接调用。
· 替代库模拟：使用crypto-js实现相同逻辑。

案例2：某登录密码字段hidetxtPassword加密。

· 搜索hidetxtPassword，找到赋值位置hidetxtPassword = r(e)。
· 进入函数r，发现其调用了外部JS文件中的方法。下载该文件，分析依赖，使用Node调用。

4.3 返回数据解密案例

案例3：某API返回数据加密，需解密后才能显示。

· 在Network中定位到返回密文的请求，下断点找到解密函数webInstance.shell。
· 该函数位于Webpack打包的JS中。识别Webpack模块加载器，导出对应模块，在Node中调用。
· 借助AI辅助编写调用代码，如：

```javascript
const fs = require('fs');
const vm = require('vm');
const code = fs.readFileSync('module.js');
const sandbox = { module: {}, exports: {} };
vm.runInNewContext(code, sandbox);
const decrypt = sandbox.module.exports;
console.log(decrypt('密文'));
```

案例4：某应用返回数据使用AES解密，但密钥由SHA1生成。

· 分析发现密钥常量s，经过SHA1加密后取前32位。
· 使用crypto-js模拟：

```javascript
const CryptoJS = require('crypto-js');
const s = "someConstant";
const key = CryptoJS.SHA1(s).toString().substr(0, 32);
const decrypted = CryptoJS.AES.decrypt('密文', key, {
    mode: CryptoJS.mode.ECB,
    padding: CryptoJS.pad.Pkcs7
}).toString(CryptoJS.enc.Utf8);
```

---

五、Sign签名机制：影响与绕过

Sign签名用于保证请求的完整性和来源可信性。它对渗透测试既有正面影响（提高安全性），也有负面影响（增加复杂度）。

5.1 Sign对测试的影响

· 正面：防止篡改、重放、未授权访问，推动测试人员深入业务逻辑。
· 负面：逆向难度大，自动化工具失效，可能掩盖其他漏洞（如输入过滤缺失）。

5.2 案例：Yakit中的签名绕过

某登录接口要求请求携带Sign，否则拒绝。通过逆向找到Sign生成逻辑：MD5(固定密钥 + 时间戳 + 请求体)。使用Yakit的Web Fuzzer，编写热加载代码动态生成Sign，实现爆破。

5.3 案例：MD5拼接型Sign绕过

某API的Sign生成：

```javascript
h = bs()(o + c + r + n + o)  // bs为MD5
o = "12b6bb84e093532fb72b4d65fec3f00b"  // 固定密钥
c = cookie中的uu参数
r = url.replace("/api", "")
n = new Date().getTime()
```

绕过步骤：

1. 通过XHR断点定位到该逻辑。
2. 提取密钥o，从cookie中获取c，计算r和n。
3. 编写脚本动态生成Sign，配合发包工具（如Python requests）实现请求。

```python
import hashlib, time, requests
o = "12b6bb84e093532fb72b4d65fec3f00b"
c = "dbbc7981-906b-45c5-8102-edf02376f9c4"
r = "/questions/lists"  # 去掉/api前缀
n = str(int(time.time()*1000))
sign = hashlib.md5((o + c + r + n + o).encode()).hexdigest()
headers = {'Sign': sign}
requests.get(url, headers=headers)
```

5.4 案例：AES加密的Sign

某翻译接口Sign由MD5生成，但密钥需从AES解密获得。逆向流程：

· 搜索sign=，找到生成位置。
· 发现w.LI固定值，t.q为待翻译词，拼接后MD5取前16位。
· 同时发现请求体中的$Q参数经过AES加密，密钥s(t)经过函数变换得到。需完整还原加密链。

---

六、代码混淆：识别与还原

混淆是保护前端代码的常用手段，但也给逆向带来巨大挑战。

6.1 混淆的意义

· 防止逆向工程
· 保护知识产权
· 减少代码体积（压缩）
· 提高安全性
· 避免自动化攻击

6.2 常见混淆手法及特征

· eval混淆：将代码字符串化后通过eval执行。特征：出现eval关键字。
· JJEncode/AAEncode/JSFuck：分别用$、颜文字、[]()!+等符号表示代码。特征：大量特殊符号堆叠。
· Obfuscator：变量名替换为_0x1234形式的十六进制，代码结构被打乱。特征：大量_0x开头的变量，难以阅读。

6.3 识别与还原方法

· eval混淆：去除eval，在控制台输出字符串，复制到编辑器格式化。
· JSFuck等：直接运行（去掉外层()），或在控制台输入代码查看结果。
· Obfuscator：使用在线工具如jsdec.js.org、lelinhtinh.github.io/de4js自动美化，或借助AST技术手动还原。

6.4 案例实战

· Eval案例：某网站JS文件开头为eval(function(p,a,c,k,e,d)...，此为eval混淆。在控制台中执行去掉eval后的字符串，得到格式化代码。
· JSFuck案例：代码由[][...]组成，复制到控制台执行，返回原始函数。
· Obfuscator案例：使用obfuscator.io生成的代码，可用deobfuscate.io部分还原。

---

七、AST语法树：高级代码还原

AST（抽象语法树）是源代码的树状表示，每个节点对应一种语法结构。通过操作AST，可以精确地还原混淆代码、提取加密逻辑。

7.1 AST基础

· 词法分析：将代码拆分为词法单元（tokens），如const、name、=、"qc"。
· 语法分析：将tokens组合成AST节点，如VariableDeclaration、Identifier、Literal。
· 代码生成：将AST转换回可执行代码。

常用工具：AST Explorer，可实时查看JS代码的AST结构。

7.2 OB混淆还原实例

OB混淆（Obfuscator.io）常见模式：将字符串拆分、拼接，或使用数组存储。还原思路：

1. 解析AST，找到定义字符串数组的节点。
2. 提取数组内容，建立映射。
3. 遍历AST，将所有通过数组访问的字符串替换为实际值。
4. 删除冗余代码，输出新代码。

示例：使用babel编写还原脚本，自动化处理。也可借助在线工具webcrack.netlify.app。

7.3 AI辅助逆向

现代AI（如ChatGPT）能快速理解混淆代码，甚至直接给出还原后的逻辑。但需注意验证准确性，AI有时会“幻觉”。

---

八、进阶工具集

工欲善其事，必先利其器。以下工具可大幅提升逆向效率。

8.1 反编译与Hook工具

· 微信小程序反编译：使用wxappUnpacker等工具解包小程序，获得源码。
· WeChatOpenDevTools：一键开启微信开发者工具，便于调试小程序。

8.2 V_Jstools

V_Jstools是一款浏览器插件，集AST、Hook、代码注入、请求修改等功能于一体，方便快速调试。

8.3 AutoDecoder

AutoDecoder是Burp插件，可根据自定义规则自动加解密数据包，适用于加密API的爆破和扫描。

8.4 JSRpc

JSRpc通过WebSocket与浏览器中的JS环境通信，实现远程调用加密函数。适合需要频繁调用加密算法的场景。

```javascript
// 注入JS环境
var demo = new Hlclient("ws://127.0.0.1:12080/ws?group=xiaodi");
// Python端调用
import requests
data = {"group": "xiaodi", "code": "console.log('hello');"}
res = requests.post("http://localhost:12080/execjs", data=data)
```

---

九、实战案例：某医疗小程序逆向

综合运用以上技术，分析某医疗小程序的加密算法。

1. 反编译：获取小程序源码。
2. 定位加密点：搜索sign，找到生成位置，发现使用crypto-js的MD5和AES。
3. 动态调试：使用WeChatOpenDevTools开启小程序调试，下断点查看密钥。
4. HOOK注入：编写脚本Hook关键函数，输出调用参数。
5. 还原算法：在Node中模拟，验证正确性。
6. 自动化：结合AutoDecoder，在Burp中自动解密响应、加密请求。

---

十、总结

JS逆向是一场永无止境的攻防博弈。开发者不断升级混淆和反调试技术，而逆向者则探索更强大的分析方法和工具。本文从开发者工具入手，系统讲解了反调试绕过、Hook插桩、加密还原、签名伪造、代码混淆与AST，并结合大量案例，希望读者能构建起完整的逆向知识框架。

未来，随着WebAssembly、代码虚拟化等技术的普及，JS逆向将面临新的挑战。但核心思路不变：理解代码逻辑，寻找薄弱环节，最终为我所用。在实践中多动手、多思考，方能立于不败之地。

---

参考资料

· 某应用断点调试指南
· AST基础与实战
· 各类在线解密工具及GitHub项目链接详见文中。引言：JS逆向与安全

JS逆向，通俗来讲，就是在浏览器调试器中，对前端代码（HTML、JS、CSS）进行分析，以理解其逻辑、获取路由、发现加密方式、挖掘敏感信息泄露等。其应用场景广泛且深入安全测试的方方面面：

· 登录框加密传输：对密码等字段进行前端加密，若未正确实现，可能导致爆破攻击失效或绕过。
· 电商折扣计算：前端计算折扣，攻击者可能篡改JS逻辑，修改价格。
· 验证码生成：若验证码生成逻辑可预测，则可绕过验证。
· 签名伪造：如某平台的X-Sign签名，逆向后可构造任意请求，实现未授权操作。
· 参数加密：逆向算法后修改Payload，测试服务端漏洞。

因此，掌握JS逆向不仅是安全研究者的必备技能，也是开发者保障前端安全的基础。本文将从开发者工具入手，逐步深入反调试、Hook、算法还原、签名绕过、代码混淆等核心领域，并结合大量真实案例，帮助读者构建完整的JS逆向知识体系。

---

一、开发者工具：逆向的基石

浏览器开发者工具（F12）是JS逆向最直观的战场。掌握其核心面板，能让后续分析事半功倍。

1.1 核心面板功能

· 网络（Network）：监控所有HTTP请求，查看请求参数、响应数据，是定位加密入口的起点。
· 源代码/来源（Sources）：查看所有加载的JS文件，可设置断点、查看作用域、调用堆栈。
· 控制台（Console）：动态执行JS代码，测试函数，输出调试信息。
· 元素（Elements）：查看DOM结构，有时可发现隐藏字段或注释中的敏感信息。

1.2 作用域与调用堆栈

· 作用域（Scope）：断点调试时，右侧Scope面板显示当前函数内的局部变量、闭包变量和全局变量。通过观察变量值变化，可快速定位加密参数生成过程。
· 调用堆栈（Call Stack）：展示函数调用的顺序，帮助我们回溯加密函数的源头。例如，在提交登录请求时，通过堆栈可找到密码加密的最终处理函数。

1.3 断点调试实战

以某应用登录接口为例：

1. 在Network中找到登录请求，定位到param加密参数。
2. 在Sources中搜索param关键词，找到相关代码行。
3. 下断点并重新触发请求，程序暂停后观察作用域中的变量，发现za(c.value, S)调用。
4. 进入函数za，分析其内部实现，识别出AES加密算法及模式（如CBC、ECB）。通过条件断点或逐步执行，最终还原加密逻辑。

参考链接：某应用断点调试详细步骤

---

二、反调试技术：对抗与绕过

为防止逆向分析，开发者常植入反调试代码。理解这些机制并掌握绕过技巧，是深入逆向的关键。

2.1 常见反调试手段

· 无限Debugger：通过setInterval或Function构造无限循环的debugger语句，使调试器持续中断。
· 键盘监听：监听F12、Ctrl+Shift+I等快捷键，禁用开发者工具。
· 检测窗口大小/高度：开发者工具打开时，窗口内外高度差会变化，通过检测此差异判断是否打开工具。
· 检测开发者工具变量：如console对象被修改、devtoolsopen等变量是否存在。
· 利用代码执行时间差：调试时代码执行速度变慢，通过计时检测。
· toString检测：检测函数是否被篡改（如Function.prototype.toString）。
· 检测非浏览器环境：如navigator.webdriver、navigator.plugins等属性。

2.2 绕过技巧

1. 禁用所有断点：在Sources面板中点击“Deactivate breakpoints”按钮，或按Ctrl+F8。
2. 禁用局部断点：右键断点选择“Remove breakpoint”，或设置条件断点使其不触发。
3. 替换文件执行：通过浏览器Overrides功能，将远程JS文件映射到本地修改后的文件，直接移除反调试代码。
4. Burp修改响应：拦截服务器返回的JS文件，删除反调试代码后再返回给浏览器。
5. 油猴插件+Hook：编写用户脚本，在页面加载前Hook反调试函数，使其失效。

2.3 案例：绕过无限Debugger

某网站使用如下代码防止调试：

```javascript
function enableDebugProtection() {
    var dbg = new Function("debugger");
    setInterval(dbg, 3000); // 每3秒触发一次debugger
}
```

绕过思路：使用油猴脚本Hook Function构造函数和setInterval。

```javascript
// ==UserScript==
// @name         Bypass Debugger
// @match        *://target.com/*
// @grant        none
// ==/UserScript==

(function() {
    // 拦截Function构造函数，若包含"debugger"则返回空函数
    const originalFunction = window.Function;
    window.Function = function(...args) {
        if (args.some(arg => arg.includes('debugger'))) {
            return function(){};
        }
        return originalFunction(...args);
    };
    // 拦截setInterval，若回调是debugger则忽略
    const originalSetInterval = window.setInterval;
    window.setInterval = function(callback, interval) {
        if (callback.toString().includes('debugger')) {
            return 0; // 返回一个假ID
        }
        return originalSetInterval(callback, interval);
    };
})();
```

更复杂的案例中，反调试代码可能隐藏在Function.prototype.constructor中，需针对性Hook。

---

三、Hook技术：动态插桩与行为修改

Hook（钩子）是一种拦截和修改JavaScript函数或对象行为的技术，广泛应用于动态分析、自动化测试和安全研究。

3.1 Hook开发基础

油猴脚本（Tampermonkey）是实现Hook的便捷工具。脚本头部需定义元信息：

```javascript
// ==UserScript==
// @name         脚本名称
// @namespace    作用域标识
// @version      版本号
// @description  描述
// @author       作者
// @match        匹配的URL规则
// @icon         图标
// @grant        特殊权限（如GM_xmlhttpRequest）
// ==/UserScript==
```

3.2 Hook原理

Hook的本质是替换原始函数，在调用前后插入自定义逻辑。例如，Hook JSON.stringify以查看序列化前的对象：

```javascript
const originalStringify = JSON.stringify;
JSON.stringify = function(obj) {
    console.log('Stringify called with:', obj);
    return originalStringify(obj);
};
```

3.3 实战案例：修改页面元素宽高

某页面检测窗口大小，当检测到开发者工具打开时，隐藏关键内容。我们可以Hook相关属性：

```javascript
Object.defineProperty(window, 'innerHeight', {
    get: function() { return 900; } // 固定值，绕过检测
});
```

3.4 实战案例：绕过Function构造函数型Debugger

某网站采用以下方式生成debugger：

```javascript
function() {}.constructor("debugger")()
```

Hook方案：

```javascript
const originalConstructor = Function.prototype.constructor;
Function.prototype.constructor = function(...args) {
    if (args[0] && args[0].includes('debugger')) {
        return function(){}; // 返回空函数
    }
    return originalConstructor.apply(this, args);
};
```

配合油猴脚本，在页面加载前注入，即可轻松绕过。

---

四、加密算法解密：扣代码与替代库

加密是JS逆向的核心难点。通过调用堆栈定位加密点后，通常有两种还原方式：扣代码直接调用，或使用替代库模拟。

4.1 定位加密点的方法

· 根据调用堆栈：提交请求时，在Network中右键请求 -> Copy -> Copy as fetch，然后在Sources中搜索相关URL，下XHR断点。触发请求后，观察调用堆栈，回溯加密函数。
· 根据参数名搜索：全局搜索参数名（如sign、param、encrypt），找到生成位置。

4.2 请求数据解密案例

案例1：某登录接口参数param加密。

· 在调用堆栈中找到za(c.value, S)，进入函数za，发现其为AES加密。
· 通过调试，确定密钥S的来源（硬编码或动态生成），以及加密模式（ECB、CBC）。
· 扣代码：将加密函数及相关依赖复制到本地Node环境，直接调用。
· 替代库模拟：使用crypto-js实现相同逻辑。

案例2：某登录密码字段hidetxtPassword加密。

· 搜索hidetxtPassword，找到赋值位置hidetxtPassword = r(e)。
· 进入函数r，发现其调用了外部JS文件中的方法。下载该文件，分析依赖，使用Node调用。

4.3 返回数据解密案例

案例3：某API返回数据加密，需解密后才能显示。

· 在Network中定位到返回密文的请求，下断点找到解密函数webInstance.shell。
· 该函数位于Webpack打包的JS中。识别Webpack模块加载器，导出对应模块，在Node中调用。
· 借助AI辅助编写调用代码，如：

```javascript
const fs = require('fs');
const vm = require('vm');
const code = fs.readFileSync('module.js');
const sandbox = { module: {}, exports: {} };
vm.runInNewContext(code, sandbox);
const decrypt = sandbox.module.exports;
console.log(decrypt('密文'));
```

案例4：某应用返回数据使用AES解密，但密钥由SHA1生成。

· 分析发现密钥常量s，经过SHA1加密后取前32位。
· 使用crypto-js模拟：

```javascript
const CryptoJS = require('crypto-js');
const s = "someConstant";
const key = CryptoJS.SHA1(s).toString().substr(0, 32);
const decrypted = CryptoJS.AES.decrypt('密文', key, {
    mode: CryptoJS.mode.ECB,
    padding: CryptoJS.pad.Pkcs7
}).toString(CryptoJS.enc.Utf8);
```

---

五、Sign签名机制：影响与绕过

Sign签名用于保证请求的完整性和来源可信性。它对渗透测试既有正面影响（提高安全性），也有负面影响（增加复杂度）。

5.1 Sign对测试的影响

· 正面：防止篡改、重放、未授权访问，推动测试人员深入业务逻辑。
· 负面：逆向难度大，自动化工具失效，可能掩盖其他漏洞（如输入过滤缺失）。

5.2 案例：Yakit中的签名绕过

某登录接口要求请求携带Sign，否则拒绝。通过逆向找到Sign生成逻辑：MD5(固定密钥 + 时间戳 + 请求体)。使用Yakit的Web Fuzzer，编写热加载代码动态生成Sign，实现爆破。

5.3 案例：MD5拼接型Sign绕过

某API的Sign生成：

```javascript
h = bs()(o + c + r + n + o)  // bs为MD5
o = "12b6bb84e093532fb72b4d65fec3f00b"  // 固定密钥
c = cookie中的uu参数
r = url.replace("/api", "")
n = new Date().getTime()
```

绕过步骤：

1. 通过XHR断点定位到该逻辑。
2. 提取密钥o，从cookie中获取c，计算r和n。
3. 编写脚本动态生成Sign，配合发包工具（如Python requests）实现请求。

```python
import hashlib, time, requests
o = "12b6bb84e093532fb72b4d65fec3f00b"
c = "dbbc7981-906b-45c5-8102-edf02376f9c4"
r = "/questions/lists"  # 去掉/api前缀
n = str(int(time.time()*1000))
sign = hashlib.md5((o + c + r + n + o).encode()).hexdigest()
headers = {'Sign': sign}
requests.get(url, headers=headers)
```

5.4 案例：AES加密的Sign

某翻译接口Sign由MD5生成，但密钥需从AES解密获得。逆向流程：

· 搜索sign=，找到生成位置。
· 发现w.LI固定值，t.q为待翻译词，拼接后MD5取前16位。
· 同时发现请求体中的$Q参数经过AES加密，密钥s(t)经过函数变换得到。需完整还原加密链。

---

六、代码混淆：识别与还原

混淆是保护前端代码的常用手段，但也给逆向带来巨大挑战。

6.1 混淆的意义

· 防止逆向工程
· 保护知识产权
· 减少代码体积（压缩）
· 提高安全性
· 避免自动化攻击

6.2 常见混淆手法及特征

· eval混淆：将代码字符串化后通过eval执行。特征：出现eval关键字。
· JJEncode/AAEncode/JSFuck：分别用$、颜文字、[]()!+等符号表示代码。特征：大量特殊符号堆叠。
· Obfuscator：变量名替换为_0x1234形式的十六进制，代码结构被打乱。特征：大量_0x开头的变量，难以阅读。

6.3 识别与还原方法

· eval混淆：去除eval，在控制台输出字符串，复制到编辑器格式化。
· JSFuck等：直接运行（去掉外层()），或在控制台输入代码查看结果。
· Obfuscator：使用在线工具如jsdec.js.org、lelinhtinh.github.io/de4js自动美化，或借助AST技术手动还原。

6.4 案例实战

· Eval案例：某网站JS文件开头为eval(function(p,a,c,k,e,d)...，此为eval混淆。在控制台中执行去掉eval后的字符串，得到格式化代码。
· JSFuck案例：代码由[][...]组成，复制到控制台执行，返回原始函数。
· Obfuscator案例：使用obfuscator.io生成的代码，可用deobfuscate.io部分还原。

---

七、AST语法树：高级代码还原

AST（抽象语法树）是源代码的树状表示，每个节点对应一种语法结构。通过操作AST，可以精确地还原混淆代码、提取加密逻辑。

7.1 AST基础

· 词法分析：将代码拆分为词法单元（tokens），如const、name、=、"qc"。
· 语法分析：将tokens组合成AST节点，如VariableDeclaration、Identifier、Literal。
· 代码生成：将AST转换回可执行代码。

常用工具：AST Explorer，可实时查看JS代码的AST结构。

7.2 OB混淆还原实例

OB混淆（Obfuscator.io）常见模式：将字符串拆分、拼接，或使用数组存储。还原思路：

1. 解析AST，找到定义字符串数组的节点。
2. 提取数组内容，建立映射。
3. 遍历AST，将所有通过数组访问的字符串替换为实际值。
4. 删除冗余代码，输出新代码。

示例：使用babel编写还原脚本，自动化处理。也可借助在线工具webcrack.netlify.app。

7.3 AI辅助逆向

现代AI（如ChatGPT）能快速理解混淆代码，甚至直接给出还原后的逻辑。但需注意验证准确性，AI有时会“幻觉”。

---

八、进阶工具集

工欲善其事，必先利其器。以下工具可大幅提升逆向效率。

8.1 反编译与Hook工具

· 微信小程序反编译：使用wxappUnpacker等工具解包小程序，获得源码。
· WeChatOpenDevTools：一键开启微信开发者工具，便于调试小程序。

8.2 V_Jstools

V_Jstools是一款浏览器插件，集AST、Hook、代码注入、请求修改等功能于一体，方便快速调试。

8.3 AutoDecoder

AutoDecoder是Burp插件，可根据自定义规则自动加解密数据包，适用于加密API的爆破和扫描。

8.4 JSRpc

JSRpc通过WebSocket与浏览器中的JS环境通信，实现远程调用加密函数。适合需要频繁调用加密算法的场景。

```javascript
// 注入JS环境
var demo = new Hlclient("ws://127.0.0.1:12080/ws?group=xiaodi");
// Python端调用
import requests
data = {"group": "xiaodi", "code": "console.log('hello');"}
res = requests.post("http://localhost:12080/execjs", data=data)
```

---

九、实战案例：某医疗小程序逆向

综合运用以上技术，分析某医疗小程序的加密算法。

1. 反编译：获取小程序源码。
2. 定位加密点：搜索sign，找到生成位置，发现使用crypto-js的MD5和AES。
3. 动态调试：使用WeChatOpenDevTools开启小程序调试，下断点查看密钥。
4. HOOK注入：编写脚本Hook关键函数，输出调用参数。
5. 还原算法：在Node中模拟，验证正确性。
6. 自动化：结合AutoDecoder，在Burp中自动解密响应、加密请求。

---

十、总结

JS逆向是一场永无止境的攻防博弈。开发者不断升级混淆和反调试技术，而逆向者则探索更强大的分析方法和工具。本文从开发者工具入手，系统讲解了反调试绕过、Hook插桩、加密还原、签名伪造、代码混淆与AST，并结合大量案例，希望读者能构建起完整的逆向知识框架。

未来，随着WebAssembly、代码虚拟化等技术的普及，JS逆向将面临新的挑战。但核心思路不变：理解代码逻辑，寻找薄弱环节，最终为我所用。在实践中多动手、多思考，方能立于不败之地。

---

参考资料

· 某应用断点调试指南
· AST基础与实战
· 各类在线解密工具及GitHub项目链接详见文中。
