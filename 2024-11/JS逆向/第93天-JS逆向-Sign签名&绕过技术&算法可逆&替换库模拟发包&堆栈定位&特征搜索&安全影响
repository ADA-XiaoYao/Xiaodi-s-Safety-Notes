引言

JS逆向，即对前端JavaScript代码进行反向分析的过程，是Web安全研究、渗透测试和漏洞挖掘中的关键技能。通过浏览器开发者工具，安全人员可以深入分析网页的逻辑、加密算法、敏感信息泄露点，甚至篡改请求数据，从而发现潜在的安全风险。本文将从基础工具使用开始，逐步深入到反调试绕过、Hook技术、算法解密和Sign签名绕过，结合多个实战案例，帮助读者系统掌握JS逆向的核心技术。

---

一、基础篇：开发者工具（F12）使用指南

1.1 F12面板概览

浏览器的开发者工具是JS逆向的“手术台”，主要包含以下关键面板：

· 元素（Elements）：查看和修改DOM结构与CSS样式，常用于定位页面元素对应的代码。
· 控制台（Console）：执行JavaScript代码、查看日志、调试输出。
· 源代码（Sources）：最核心的面板，用于查看所有加载的JS文件、设置断点、观察作用域和调用堆栈。
· 网络（Network）：监控所有HTTP请求，查看请求参数、响应头和响应体，是定位加密接口的入口。

1.2 作用域（Scope）

当在Sources面板中断点调试时，右侧的Scope面板会显示当前执行上下文中的变量值（局部、闭包、全局）。通过观察变量变化，可以快速定位加密函数中的关键参数。

1.3 调用堆栈（Call Stack）

调用堆栈记录了代码执行的完整路径。当在某处断下时，堆栈窗口会显示从入口到当前位置的函数调用顺序。这对于追踪加密逻辑的起点至关重要——例如，看到提交按钮事件触发后的一系列函数，最终找到加密函数的位置。

1.4 断点调试

断点是逆向分析的核心手段。常用断点类型包括：

· 代码行断点：在Sources面板中点击行号即可设置。
· XHR/提取断点（XHR/fetch Breakpoints）：在Sources右侧的XHR Breakpoints面板中，可以设置匹配特定URL的断点，当请求发送前自动断下。
· DOM断点：监听DOM元素被修改、删除或属性变化。
· 事件监听器断点：在Sources右侧的Event Listener Breakpoints中，可以勾选鼠标点击、键盘事件等，当事件触发时断下。

参考链接：公众号文章（提供了更详细的断点调试示例）

---

二、反调试技术与绕过方法

为了保护代码不被调试，开发者常采用反调试技术。掌握绕过方法是逆向深入的关键。

2.1 常见反调试手段

1. 无限Debugger
   ```javascript
   function enableDebugProtection() {
       var dbg = new Function("debugger");
       setInterval(dbg, 3000); // 每3秒触发一次debugger
   }
   ```
   或者使用 Function 构造函数：
      function() {}.constructor("debugger")()
2. 键盘监听（F12）
      监听 keydown 事件，当按下F12时执行 debugger 或清空控制台。
3. 检测浏览器窗口大小/高度
      判断 window.outerHeight - window.innerHeight > 100，认为开发者工具打开。
4. 检测开发者工具变量
      如检查 window.console 是否被重写，或 console.log 调用次数。
5. 代码运行时间差
      利用 console.log 大量输出导致时间差，判断是否被调试。
6. toString 检测
      检测函数是否被原生 toString 方法标识为“native code”，判断是否被Hook。
7. 检测非浏览器环境
      如检测 navigator.webdriver 属性。

2.2 绕过技巧

1. 禁用所有断点：在Sources面板中，点击“Deactivate breakpoints”按钮（或按Ctrl+F8），暂时禁用所有断点，跳过无限Debugger。
2. 禁用局部断点：在无限Debugger代码行上右键，选择“Never pause here”，跳过该行。
3. 条件断点：在无限Debugger行设置条件断点，如 false，使其不会暂停。
4. 替换文件执行：使用浏览器Overrides功能，将修改后的JS文件保存到本地，替换服务器文件，彻底删除反调试代码。
5. Burp修改匹配：通过Burp Suite拦截响应，修改返回的JS内容，移除反调试代码。
6. 油猴插件配合Hook：编写油猴脚本，在页面加载时Hook相关函数，绕过检测。

案例：绕过无限Debugger

假设目标代码为：

```javascript
function() {}.constructor("debugger")()
```

我们可以编写油猴脚本：

```javascript
// ==UserScript==
// @name         Bypass Debugger
// @namespace    http://tampermonkey.net/
// @version      0.1
// @description  绕过 Function 构造函数中的 debugger
// @author       You
// @match        *://target.com/*
// @grant        none
// ==/UserScript==

(function() {
    const originalConstructor = Function.prototype.constructor;
    Function.prototype.constructor = function(...args) {
        if (args[0] && args[0].includes('debugger')) {
            console.log('Blocked debugger constructor');
            return function(){}; // 返回空函数
        }
        return originalConstructor.apply(this, args);
    };
})();
```

该脚本拦截了所有通过 Function 创建的字符串，如果包含 debugger，则返回一个空函数，从而绕过。

---

三、Hook技术：动态拦截与修改

Hook（钩子）是一种拦截和修改JavaScript函数或对象行为的技术，常用于动态分析、修改页面功能、自动化测试和安全研究。

3.1 Hook原理

通过替换原始函数，在函数调用前后插入自定义逻辑。例如，Hook eval 可以捕获所有动态执行的代码，Hook JSON.parse 可以查看解析前的原始数据。

3.2 油猴脚本开发前置

油猴脚本头部通常包含以下元信息：

· @name：脚本名称
· @namespace：命名空间
· @version：版本
· @description：描述
· @author：作者
· @match：匹配的URL规则
· @grant：申请的权限（如 GM_xmlhttpRequest）

3.3 实战案例：修改元素显示尺寸

目标：网页某个元素被隐藏或尺寸限制，我们希望强制显示。

```javascript
// ==UserScript==
// @name         Unhide Element
// @match        *://example.com/*
// @grant        none
// ==/UserScript==

(function() {
    // 等待DOM加载完成
    window.addEventListener('load', function() {
        var elem = document.getElementById('hidden-box');
        if (elem) {
            elem.style.display = 'block';
            elem.style.height = 'auto';
        }
    });
})();
```

3.4 实战案例：绕过无限Debugger（续）

前面已经展示了通过Hook Function 构造函数来绕过。类似的，可以Hook setInterval 防止定时执行debugger。

---

四、算法解密：从定位到实现

在逆向中，最核心的任务往往是解密请求参数或响应数据。下面通过几个案例讲解常见的分析方法。

4.1 请求数据解密（AES）

场景：登录请求中密码被加密，参数名为 param。

步骤：

1. 定位加密点：在Network面板中找到登录请求，查看 param 的值。右键该请求 -> “Copy as cURL”，然后切换到Sources面板，使用搜索功能（Ctrl+Shift+F）搜索 param 或部分加密串，找到可能的赋值位置。
2. 下断点跟踪：在搜索到的代码行设置断点，重新触发登录，观察调用堆栈。发现加密函数为 za(c.value, S)。
3. 分析算法：进入 za 函数，发现它调用了CryptoJS的AES方法，模式为ECB，填充为Pkcs7。密钥 S 可能从何处获取？通过作用域查看，S 是一个写死的字符串。
4. 验证：在控制台手动调用 za 传入已知密码，看输出是否与请求一致。确认后即可用Python或Node.js复现。

4.2 请求数据解密（扣代码调用）

有时加密代码较为复杂，但我们可以将整个加密模块“抠出来”直接调用。

场景：某网站注册请求中，密码字段 hidetxtPassword 被加密。

步骤：

1. 在Network中定位请求，搜索 hidetxtPassword，找到加密函数位置。
2. 发现该函数引用了一个独立的加密JS文件（如 rsa.js），里面包含RSA加密逻辑。
3. 下载该JS文件，并利用Node.js环境运行。可能需要补全缺失的全局变量（如 window）。通常使用 jsdom 或 vm2 模块模拟浏览器环境。
4. 编写Node脚本，导出加密函数，传入明文获取密文，实现自动化加密。

4.3 返回数据解密（Webpack打包）

现代前端常使用Webpack打包，模块被封装在 webpackJsonp 中，需要找到正确的加载器。

场景：某API返回的数据是加密的，需要解密后才能查看明文。通过XHR断点定位到解密函数 webInstace.shell。

步骤：

1. 在Sources中搜索 webInstace.shell，找到其定义。发现它在一个Webpack模块中，模块ID为 123。
2. 找到Webpack的加载器函数（通常是 function(e)），在控制台中执行 window.webpackJsonp.push 或直接调用加载器加载该模块。
3. 拿到 webInstace 对象后，编写Node脚本模拟调用。由于Webpack模块依赖其他模块，可能需要手动补全依赖，或直接在浏览器控制台保存函数到全局，再复制到Node。

4.4 返回数据解密（替代库模拟）

如果加密算法是标准算法（如AES、SHA1），我们无需扣整个JS，只需用标准库模拟。

场景：返回数据为AES加密，密钥由SHA1生成。

步骤：

1. 分析发现解密过程：o 是密文，key 是 s 经过SHA1后取前32位。
2. 在Node中安装 crypto-js：
   ```bash
   npm init -y
   npm install crypto-js
   ```
3. 编写脚本：
   ```javascript
   const CryptoJS = require('crypto-js');
   let s = "someConstant";
   let key = CryptoJS.SHA1(s).toString().substr(0, 32); // 前32位
   let decrypted = CryptoJS.AES.decrypt(o, key, {
       mode: CryptoJS.mode.ECB,
       padding: CryptoJS.pad.Pkcs7
   });
   console.log(decrypted.toString(CryptoJS.enc.Utf8));
   ```

---

五、Sign签名机制：影响与绕过

Sign签名广泛用于API请求的完整性校验和防篡改。它对渗透测试既有积极影响，也带来了挑战。

5.1 Sign的正面影响

· 防篡改：签名基于请求参数和密钥，修改参数会导致签名失效。
· 防重放：结合时间戳和随机数，使请求无法被重放。
· 防未授权访问：只有携带正确签名的请求才被服务器处理。

5.2 Sign的负面影响

· 增加测试复杂度：需要逆向签名算法，每次修改请求都需重新计算签名。
· 自动化扫描失效：传统扫描器无法自动处理签名，导致漏报。
· 可能掩盖其他漏洞：开发者过度依赖签名，忽略输入过滤、权限控制等基础安全措施。

5.3 绕过Sign的常见思路

1. 逆向算法，本地模拟签名：通过JS逆向获得签名算法，在测试工具（如Burp、Yakit）中集成签名计算。
2. 篡改客户端代码，禁用签名校验：使用油猴脚本Hook签名函数，使其返回固定值或跳过。
3. 寻找签名逻辑缺陷：例如签名只验证部分参数、密钥硬编码在客户端、时间戳范围过大等。

5.4 案例1：使用Yakit进行签名爆破

场景：某登录接口需要签名 Sign，用于防止暴力破解。

步骤：

1. 抓包发现请求体包含 username、password 和时间戳 ts，以及 Sign 字段。
2. 逆向JS发现签名算法为 MD5(username + password + ts + secretKey)，其中 secretKey 是固定的。
3. 在Yakit中编写插件，对每个爆破的密码组合动态计算签名，并发起请求，从而实现绕过签名校验的爆破。

5.5 案例2：某应用Sign逆向

目标：/api/questions/lists 接口需要携带 Sign 头。

步骤：

1. 入口定位：在Network中找到该请求，右键 -> “Copy as cURL”，然后在Sources中搜索URL的一部分，或设置XHR断点匹配该URL。
2. 调用堆栈：断下后，查看调用堆栈，找到添加 Sign 头的地方。代码为：
   ```javascript
   t.headers.Sign = h;
   h = bs()(o + c + r + n + o);
   ```
3. 分析 bs()：下断点到 bs，发现它返回的是 crypto.MD5 函数。确认算法为MD5。
4. 提取参数：
   · o：固定字符串 "12b6bb84e093532fb72b4d65fec3f00b"
   · c：从cookie中获取的值 "dbbc7981-906b-45c5-8102-edf02376f9c4"
   · r：t.url.replace("/api", "")，即 /questions/lists
   · n：(new Date).getTime() 时间戳
5. 验证：在控制台执行 crypto.MD5(o + c + r + n + o).toString()，与请求中的Sign对比一致。
6. 自动化：编写Python脚本，模拟该签名算法，用于后续测试。

5.6 案例3：翻译接口Sign逆向

目标：某翻译接口，参数 q（查询词）和 sign。

步骤：

1. 搜索定位：全局搜索 sign=，找到生成签名的代码。
2. 分析算法：
   ```javascript
   y()("6key_web_new_fanyi".concat(w.LI).concat(t.q.replace(/(^\s*)|(\s*$)/g, ""))).toString().substring(0, 16);
   ```
   其中 y() 是MD5函数，w.LI 是固定密钥 6dVjYLFyzfkFkk。
3. 拼接顺序：6key_web_new_fanyi + 6dVjYLFyzfkFkk + 去除空格后的查询词 → MD5 → 取前16位。
4. 验证：手工计算一个词的签名，与请求一致。
5. 进一步发现：后续还有AES加密参数，密钥 r = s(t) = "L4fBtD5fLC9FQw22"，使用ECB模式。可一并模拟。

---

六、总结与防御建议

JS逆向是Web安全测试的必备技能，它帮助我们深入理解前端逻辑，发现隐藏的漏洞。然而，逆向技术本身也是攻防对抗的一部分。对于开发者而言，以下措施可以增加逆向难度：

· 代码混淆：使用工具如UglifyJS、Jscrambler混淆变量名和控制流。
· 反调试技术：结合多种反调试手段，并定期更新。
· 动态密钥：密钥从服务器动态获取，避免硬编码。
· 签名加固：使用非对称加密（如RSA）对签名密钥进行保护，或采用HMAC结合服务器时间戳。
· 服务端校验：所有关键校验必须在服务端完成，不能依赖客户端。

对于安全测试人员，掌握JS逆向意味着能够穿透前端的“黑盒”，直击业务逻辑的核心。希望本文的案例和方法能为您提供实用的参考。

---

本文内容基于实际渗透测试经验整理，仅供技术学习和安全研究使用，请勿用于非法目的。
