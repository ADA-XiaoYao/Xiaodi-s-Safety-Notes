移动应用安全分析中，动态调试是一项核心技能。通过动态调试，安全研究人员可以实时追踪代码执行流程、查看内存数据、分析加密算法，甚至修改应用行为。本文将结合理论原理与实战操作，详细介绍基于JEB、ADB以及Cheat Engine的APP动态调试与内存修改技术，并通过两个真实案例加深理解。

1. 动态调试基础与环境准备

1.1 模拟器配置与开发者模式

动态调试通常在模拟器或真机上进行，且需要开启调试相关选项。以Android模拟器为例，需完成以下步骤：

· 启用开发者模式：进入“设置” → “关于平板电脑”，连续点击“版本号”5次。
· 开启USB调试：在“系统” → “高级” → “开发者选项”中，开启“USB调试”。
· 赋予Root权限及磁盘写入：模拟器设置中开启Root权限，并允许系统分区可写（部分调试操作需要修改文件）。

1.2 JEB与ADB环境配置

JEB是一款强大的Android反编译与动态调试工具，依赖JDK和ADB（Android Debug Bridge）。

· JDK 11安装：下载JDK 11并设置环境变量 JAVA_HOME，确保JEB启动时使用正确版本。
· ADB配置：将Android SDK平台工具路径（含adb.exe）加入系统PATH，JEB需调用ADB与设备通信。
· JEB激活：可参考社区资源（如52pojie）获取激活方法。

2. APP动态调试核心操作

2.1 使APP可调试

默认发布的APK通常设置 android:debuggable="false"，需修改为 true 才能附加调试器。方法包括：

· 修改AndroidManifest.xml，在<application>标签中添加 android:debuggable="true"，然后重打包签名。
· 使用工具如apktool解包修改，或通过mprop等运行时修改（需要root）。
  其他技巧可参考52pojie相关帖子。

2.2 ADB连接模拟器

不同模拟器的ADB连接端口不同，常用命令如下：

```bash
# MuMu模拟器
adb connect 127.0.0.1:7555
# 夜神模拟器
adb connect 127.0.0.1:62001
# 雷电模拟器
adb connect 127.0.0.1:5555
# 逍遥安卓
adb connect 127.0.0.1:21503
# 天天模拟器
adb connect 127.0.0.1:6555
# 海马玩
adb connect 127.0.0.1:53001
```

连接成功后，adb devices 应显示设备列表。

2.3 以调试模式启动APP

使用am命令以调试模式启动目标Activity，格式：

```bash
adb shell am start -D -n 包名/完整类名
```

例如，对靶场应用com.zj.wuaipojie的主界面：

```bash
adb shell am start -D -n com.zj.wuaipojie/.ui.MainActivity
```

执行后应用会进入等待调试器附加的状态（显示“Waiting for Debugger”）。

2.4 JEB动态调试附加

1. 在JEB中打开反编译的APK。
2. 点击菜单栏 Debugger → Start，选择设备与进程（此时应看到处于等待调试的进程）。
3. JEB附加后，应用继续运行，可在代码中下断点、单步跟踪、查看变量等。

3. 案例1：靶场密钥验证

场景：某CTF靶场应用在启动时要求输入密钥，验证逻辑隐藏在native层或混淆后的Java代码中。目标是通过动态调试绕过验证或提取正确密钥。

3.1 定位关键代码

· 反编译后搜索关键词如“key”“check”“verify”，找到可能的验证函数。
· 在JEB中定位到MainActivity的onClick或onCreate中处理输入的部分。

3.2 动态调试分析

1. 以调试模式启动应用。
2. 在JEB中下断点于验证函数入口。
3. 输入任意密钥，点击确认，程序断下。
4. 单步执行，观察寄存器与变量变化，跟踪比较逻辑。例如，可能发现密钥与硬编码字符串比较，或经过某种变换后与常量比较。
5. 若为简单比较，可直接修改内存中的输入值或比较结果寄存器，实现绕过。

3.3 内存修改

· 在JEB的调试视图中，找到存储输入字符串的内存地址，直接修改为正确值。
· 或修改比较指令的跳转条件（如将if-eq改为if-ne）并记录修改后的字节码，后续可制作补丁。

通过此案例，掌握动态调试的基本流程：定位关键点 → 下断 → 追踪数据流 → 修改行为。

4. 案例2：嘟嘟牛登录加解密算法还原

场景：某APP“嘟嘟牛”登录时，抓包发现密码字段被加密为一段Base64字符串，目标是还原加密算法，以便实现自动化登录或安全评估。

4.1 抓包分析

· 使用Burp Suite或Charles设置代理，抓取登录请求。
· 观察到POST数据中包含encrypted_pwd字段，值为类似bG9naW46cGFzc3dvcmQ=的字符串（Base64编码）。
· 初步猜测可能是简单编码或自定义加密。

4.2 反编译定位加密函数

· 将APK拖入JEB，搜索关键词“password”“encrypt”“encode”“login”。
· 在登录相关类（如LoginActivity或ApiService）中找到密码处理函数。可能调用某个加密工具类的方法。

4.3 动态调试追踪算法

1. 在加密函数入口处下断点。
2. 正常登录，触发断点。
3. 单步跟踪，观察传入的明文密码，以及经过的运算步骤。常见算法包括：
   · 简单拼接盐值后计算MD5。
   · AES/DES加密（注意查找密钥和IV）。
   · 自定义异或、位移等操作。
4. 记录每一步的中间结果，结合JEB的变量窗口，还原出完整的加密逻辑。

4.4 算法还原与验证

假设通过跟踪发现加密流程为：

· 密码字符串先与固定字符串“salt”拼接。
· 然后进行3次MD5哈希。
· 最后Base64编码。
  则可用Python脚本复现：

```python
import hashlib, base64
def encrypt(password):
    s = password + "salt"
    for _ in range(3):
        s = hashlib.md5(s.encode()).hexdigest()
    return base64.b64encode(s.encode()).decode()
```

将生成的密文与抓包数据比对，验证还原的正确性。

此案例展示了如何结合静态分析与动态调试，逐步还原应用的自定义加密算法。

5. 内存修改进阶：Cheat Engine在安卓中的应用

Cheat Engine（CE）是知名的游戏内存修改工具，也可用于安卓应用的内存数据搜索与修改，尤其适合修改数值类数据（如金币、生命值）或标志位。

5.1 服务端部署

CE需要服务端在Android设备上运行，提供内存访问接口。

· 下载CE的Android服务端（如ceserver_x86_64），推送到模拟器：
  ```bash
  adb push ceserver_x86_64 /data/local/tmp/
  ```
· 进入shell，赋予执行权限并运行：
  ```bash
  adb shell
  cd /data/local/tmp
  chmod 777 ceserver_x86_64
  ./ceserver_x86_64
  ```
· 端口转发，将设备的52736端口映射到本地：
  ```bash
  adb forward tcp:52736 tcp:52736
  ```

5.2 CE连接与内存搜索

· 在PC端打开Cheat Engine，点击“文件” → “附加到进程”，选择“网络”选项，输入127.0.0.1和端口52736。
· 选择目标应用进程。
· 使用CE的内存搜索功能，例如搜索当前金币数值，修改后观察应用变化。

5.3 实战应用

在游戏类应用中，可通过CE修改内购标志或虚拟货币。在安全分析中，可定位关键标志位（如VIP状态）的内存地址，分析其写入逻辑，进而找到相关代码。

6. 总结与防御建议

动态调试与内存修改是移动安全分析的双刃剑。对攻击者而言，可借此突破应用保护；对防御者而言，了解这些技术有助于设计更健壮的安全方案。

· 动态调试：通过修改android:debuggable、附加调试器、跟踪代码，可深入理解应用逻辑。
· 内存修改：利用CE等工具可直接篡改运行时数据，绕过客户端检查。
· 防御建议：
  · 发布应用时务必设置android:debuggable="false"。
  · 对关键逻辑进行加固（如代码混淆、反调试检测）。
  · 重要数据尽量在服务端验证，避免依赖客户端安全性。

本文通过理论讲解与案例实操，涵盖了从环境搭建到高级调试的完整流程。读者可跟随步骤亲手实践，加深对APP安全分析的理解。
