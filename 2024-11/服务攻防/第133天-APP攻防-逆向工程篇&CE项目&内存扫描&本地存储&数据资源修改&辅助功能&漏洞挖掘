你以为前端加密就安全了？黑客直接用CE在内存中给你把算法改了。本文带你揭开内存修改的神秘面纱，掌握让加密形同虚设的终极技巧。

一、核心工具：Cheat Engine 的前世今生

Cheat Engine（简称CE） 是一款开源的内存扫描与修改工具，最初用于游戏修改，但在安全测试领域，它是发现本地验证漏洞的利器。

核心原理：当程序将某些关键数据（如金币、体力、密钥）暂存在内存中时，CE可以直接扫描内存、定位这些数据并对其进行修改。如果程序在后续与服务器的交互中直接使用了这些被篡改的内存数据，且服务端缺乏有效校验，就会产生安全漏洞。

二、实战四大场景：从基础到进阶

场景1：基础内存修改——以“淘小说/壁纸”APP为例

这是最经典的数值修改场景，适用于游戏金币、APP积分、阅读币等有明显数值变化的场景。

操作步骤：

1. 绑定进程：打开APP或小程序，在CE中点击“选择进程”图标（小电脑），在进程列表中找到对应的进程。技巧：可通过任务管理器观察哪个进程在你操作APP时内存暴增，将其PID转换为16进制后能在CE中快速定位。
2. 首次扫描：在CE“值”栏输入当前看到的数值（如金币：100），点击“首次扫描”。
3. 筛选地址：
   · 在APP中消耗一点金币（如变成90），在CE选择“减少的数值”再次扫描。
   · 重复“操作APP -> 选择变化类型 -> 再次扫描”的步骤，直到地址列表只剩下几个或十几个。
4. 修改验证：将筛选出的地址加入下方列表，双击“值”进行修改。回APP触发一次数值变动，若修改生效，则说明漏洞存在。

进阶技巧：

· 遇到加密数值怎么办？ 如果直接搜索数值找不到，说明数据可能被简单加密（如乘以2）。此时使用未知初始值扫描，然后根据数值的“增加”、“减少”、“不变”反复筛选，最终找到的内存值可能就是明文的2倍或其他线性关系。

场景2：本地数据修改——伪造社交聊天记录

此场景适用于修改APP的本地配置文件或数据库，实现如伪造聊天记录、解锁VIP状态等功能。

操作思路：

1. 文件定位：对于不存储于服务器的重要数据，APP会保存在本地。通过adb连接调试手机或分析APP的安装目录，找到存储关键信息的文件（如SQLite数据库.db、SharedPreference.xml或文本文件）。
2. 数据修改：
   · SQLite数据库：使用SQLite浏览器打开，直接修改messages表中的聊天内容、时间戳或发送者ID。
   · XML/JSON文件：用文本编辑器修改VIP过期时间、用户等级等键值对。
3. 重启验证：修改保存后，重启APP观察修改是否生效。

防御视角：敏感数据应加密存储，且服务端需对关键操作（如发送消息）进行校验，防止仅修改本地就伪造出服务端认可的数据。

场景3：加密场景下的替代方案——突破Burp抓包困境

当遇到小程序或APP的请求包和响应包全是加密数据，导致Burp Suite无法分析时，CE提供了一条“曲线救国”的路径。

适用情况：数据包加密，但前端显示的数据（如价格、数量）在内存中是明文。
操作步骤：

1. 进程附加：同场景1，将CE附加到目标进程。
2. 搜索前端数值：直接在CE中搜索你在前端页面上看到的数值（例如商品价格：200）。
3. 批量修改：找到地址后，不局限于单个修改，可以进行批量修改（如将库存数量从200统一改为300）。
4. 下单触发：在APP中发起购买或下单操作，观察是否以修改后的数值生成了请求包。虽然包是加密的，但若服务端处理了篡改后的数据，即可证明漏洞存在。

核心价值：这种方法完全绕过了对加密数据包的解密过程，直接攻击了数据源头。

场景4：王者进阶——固定动态AES密钥实现自动化加解密

这是最高阶的玩法，适用于每次请求都使用动态AES密钥，且密钥被RSA加密传输的高安全场景。攻击者通过CE将动态密钥生成算法改为固定值，再配合Burp插件实现自动化加解密，让加密形同虚设。

核心步骤：

第一步：反编译分析

· 对小程序包进行反编译，找到加解密相关代码。假设分析发现其使用 AES/ECB/PKCS7Padding 算法，密钥key是每次随机生成的16位字符串。

第二步：CE内存修改——固定密钥

1. 搜索关键字符串：在CE中附加小程序进程，搜索与密钥生成相关的关键字符串，例如密钥生成的算法代码区域。
2. 定位修改点：在内存中找到生成随机密钥的算法部分。目标是将其改为固定返回一个我们知道的字符串（如AAAAAAAAAAAAAAAA）。
3. 修改汇编/数据：
   · 一种粗暴但有效的方式：找到生成密钥后存放结果的内存地址，直接在CE中将其修改为固定的字节数据（例如32个A的十六进制41）。
   · 关键操作：右键该地址 -> “浏览相关内存区域”，找到代表算法的字节码，将其修改为mov eax, 0x41414141之类的固定赋值指令（需要一定的汇编基础）。
4. 激活与重启：将修改后的地址加入CT表并勾选“激活”。反复重启小程序，观察内存中的值是否已固定为我们设置的AAAA...。

第三步：Galaxy插件自动化加解密

1. 环境准备：安装aws-corretto-jdk（避免Oracle JDK的兼容问题），并在Burp中加载Galaxy插件。
2. 编写解密脚本：基于GalaxyHttpHooker模板，编写FastAPI脚本。核心逻辑是处理四个方向的流量：
   · hookRequestToBurp：将客户端发来的密文（去除双引号 -> base64解码 -> AES解密）转为明文供分析。
   · hookRequestToServer：将Burp中的明文（AES加密 -> base64编码 -> 添加双引号）还原为密文发往服务端。
   · hookResponseToBurp / hookResponseToClient 同理处理响应包。
3. 配置与运行：
   · 在Burp的Galaxy标签页中，设置目标Host，并指定加解密脚本监听的地址（如http://127.0.0.1:9000）。
   · 运行写好的Python脚本（uvicorn script_name:app --host 0.0.0.0 --port 9000）。
4. 享受明文世界：此时，在Burp的HTTP History、Repeater中，所有原本加密的请求和响应都将以明文形式显示，你可以像测试普通Web应用一样进行漏洞挖掘。

三、从入门到精通的几点思考

1. 工具是死的，思路是活的：CE不仅能改数值，还能改逻辑。从改金币到固定密钥，本质上是从修改数据到修改控制流的思维跃迁。
2. 加密 ≠ 安全：再强的加密算法，密钥若在客户端内存中明文暴露或可被篡改，整个加密体系就形同虚设。客户端是最不可信的环境。
3. 防御建议：
   · 关键数据服务端校验：游戏充值、下单等操作，最终数值必须与服务端日志或数据库比对。
   · 内存保护：对关键内存区域进行校验，或使用白盒加密方案增加分析难度。
   · 完整性检测：对小程序的包完整性、Hook框架进行检测，增加修改门槛。

四、资源与延伸阅读

· CE下载：官方地址 或 吾爱破解论坛
· 本文涉及工具与脚本：
  · Galaxy插件：https://github.com/outlaws-bai/Galaxy
  · 加解密脚本Demo：https://github.com/outlaws-bai/GalaxyHttpHooker

希望这份笔记对你的读者有所帮助。技术是一把双刃剑，请务必在合法授权范围内进行测试和学习。
